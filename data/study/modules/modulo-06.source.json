{
  "header": {
    "badge": "MÃ³dulo 6 de 9",
    "title": "ExpressÃµes Regulares",
    "subtitle": "A notaÃ§Ã£o algÃ©brica das linguagens regulares â€” e as trÃªs conversÃµes que fecham o triÃ¢ngulo AFD â†” AFN â†” ER.",
    "meta": [
      "~60 min",
      "NÃ­vel: IntermediÃ¡rio",
      "Testador de ER + ConstruÃ§Ã£o de Thompson"
    ],
    "progressLabel": "MÃ³dulo 6 de 9 â€” ExpressÃµes Regulares"
  },
  "navLinks": [
    {
      "id": "sintaxe",
      "label": "Sintaxe"
    },
    {
      "id": "semantica",
      "label": "SemÃ¢ntica"
    },
    {
      "id": "precedencia",
      "label": "PrecedÃªncia"
    },
    {
      "id": "exemplos",
      "label": "Exemplos"
    },
    {
      "id": "testador",
      "label": "Testador"
    },
    {
      "id": "thompson",
      "label": "Thompson"
    },
    {
      "id": "eliminacao",
      "label": "ERâ†’AFD"
    },
    {
      "id": "triangulo",
      "label": "TriÃ¢ngulo"
    },
    {
      "id": "quiz",
      "label": "ExercÃ­cios"
    },
    {
      "id": "resumo",
      "label": "Resumo"
    }
  ],
  "html": "<section id=\"sintaxe\">\n  <h2><span class=\"num\">1</span> O que Ã© uma expressÃ£o regular?</h2>\n\n  <p>Uma <strong>expressÃ£o regular (ER)</strong> Ã© uma fÃ³rmula que descreve um conjunto de strings â€” uma linguagem â€” usando trÃªs operaÃ§Ãµes primitivas: <em>uniÃ£o</em>, <em>concatenaÃ§Ã£o</em> e <em>fecho de Kleene</em>.</p>\n\n  <p>Diferente de um autÃ´mato (que Ã© uma mÃ¡quina), uma ER Ã© uma notaÃ§Ã£o <em>declarativa</em>: ela descreve o que a linguagem contÃ©m, nÃ£o como reconhecÃª-la.</p>\n\n  <div class=\"fbox purple\">\n    <span class=\"flabel\">DefiniÃ§Ã£o indutiva â€” ExpressÃ£o Regular sobre Î£</span>\n    <div style=\"text-align:left; max-width:420px; margin:0.8rem auto 0; font-size:0.95rem; line-height:2;\">\n      Base:<br>\n      &nbsp;&nbsp;â€¢ âˆ… Ã© uma ER (linguagem vazia)<br>\n      &nbsp;&nbsp;â€¢ Îµ Ã© uma ER (linguagem {Îµ})<br>\n      &nbsp;&nbsp;â€¢ a Ã© uma ER para cada a âˆˆ Î£ (linguagem {a})<br>\n      InduÃ§Ã£o: se R e S sÃ£o ERs, entÃ£o:<br>\n      &nbsp;&nbsp;â€¢ (R âˆª S) Ã© uma ER â€” uniÃ£o<br>\n      &nbsp;&nbsp;â€¢ (R âˆ˜ S) ou (RS) Ã© uma ER â€” concatenaÃ§Ã£o<br>\n      &nbsp;&nbsp;â€¢ (R*) Ã© uma ER â€” fecho de Kleene\n    </div>\n  </div>\n\n  <h3>NotaÃ§Ã£o na prÃ¡tica</h3>\n  <table>\n    <tbody><tr><th>OperaÃ§Ã£o</th><th>NotaÃ§Ã£o formal</th><th>NotaÃ§Ã£o comum</th><th>Significado</th></tr>\n    <tr><td>UniÃ£o</td><td><code>R âˆª S</code></td><td><code>R|S</code></td><td>Strings em R ou S</td></tr>\n    <tr><td>ConcatenaÃ§Ã£o</td><td><code>R âˆ˜ S</code></td><td><code>RS</code></td><td>String de R seguida de string de S</td></tr>\n    <tr><td>Kleene star</td><td><code>R*</code></td><td><code>R*</code></td><td>Zero ou mais repetiÃ§Ãµes de R</td></tr>\n    <tr><td>Kleene plus</td><td><code>R âˆ˜ R*</code></td><td><code>R+</code></td><td>Uma ou mais repetiÃ§Ãµes de R (abreviaÃ§Ã£o)</td></tr>\n    <tr><td>Opcional</td><td><code>Îµ âˆª R</code></td><td><code>R?</code></td><td>Zero ou uma ocorrÃªncia de R (abreviaÃ§Ã£o)</td></tr>\n  </tbody></table>\n\n  <div class=\"callout tip\">\n    <strong>R+ e R? sÃ£o abreviaÃ§Ãµes</strong> â€” nÃ£o sÃ£o operaÃ§Ãµes primitivas. O modelo mÃ­nimo usa apenas âˆª, concatenaÃ§Ã£o e *. As formas abreviadas aparecem em ferramentas prÃ¡ticas (grep, sed, linguagens de programaÃ§Ã£o) mas nÃ£o na definiÃ§Ã£o teÃ³rica.\n  </div>\n</section>\n\n<section id=\"semantica\">\n  <h2><span class=\"num\">2</span> SemÃ¢ntica â€” o que cada ER denota</h2>\n\n  <p>Cada ER R denota uma linguagem L(R). A definiÃ§Ã£o Ã© indutiva, acompanhando a sintaxe:</p>\n\n  <table>\n    <tbody><tr><th>ExpressÃ£o</th><th>Linguagem denotada L(R)</th></tr>\n    <tr><td><code>âˆ…</code></td><td>âˆ… (linguagem vazia â€” nenhuma string)</td></tr>\n    <tr><td><code>Îµ</code></td><td>{Îµ} (apenas a string vazia)</td></tr>\n    <tr><td><code>a</code></td><td>{a} (string de comprimento 1)</td></tr>\n    <tr><td><code>R|S</code></td><td>L(R) âˆª L(S)</td></tr>\n    <tr><td><code>RS</code></td><td>L(R) âˆ˜ L(S) = {xy | xâˆˆL(R), yâˆˆL(S)}</td></tr>\n    <tr class=\"hl\"><td><code>R*</code></td><td>L(R)* = {xâ‚xâ‚‚â€¦xâ‚– | kâ‰¥0, cada xáµ¢âˆˆL(R)}</td></tr>\n  </tbody></table>\n\n  <div class=\"callout key\">\n    <strong>Teorema de Kleene:</strong> uma linguagem Ã© regular se e somente se pode ser descrita por uma expressÃ£o regular. Esse Ã© o terceiro lado do triÃ¢ngulo: ER, AFD e AFN reconhecem exatamente as mesmas linguagens.\n  </div>\n\n  <h3>Identidades algÃ©bricas importantes</h3>\n  <div class=\"card\">\n    <table style=\"font-size:0.88rem; margin:0;\">\n      <tbody><tr><th>Identidade</th><th>ExplicaÃ§Ã£o</th></tr>\n      <tr><td><code>âˆ…* = Îµ</code></td><td>Zero concatenaÃ§Ãµes de strings de âˆ… dÃ¡ Îµ</td></tr>\n      <tr><td><code>Îµ* = Îµ</code></td><td>Kleene de Îµ ainda Ã© sÃ³ Îµ</td></tr>\n      <tr><td><code>âˆ…R = Râˆ… = âˆ…</code></td><td>Concatenar com âˆ… anula tudo</td></tr>\n      <tr><td><code>ÎµR = RÎµ = R</code></td><td>Îµ Ã© o neutro da concatenaÃ§Ã£o</td></tr>\n      <tr><td><code>âˆ…|R = R|âˆ… = R</code></td><td>âˆ… Ã© o neutro da uniÃ£o</td></tr>\n      <tr><td><code>R** = R*</code></td><td>Star Ã© idempotente</td></tr>\n      <tr><td><code>(R|S)* = (R*S*)* = (R*|S*)*</code></td><td>Identidade de Kleene</td></tr>\n    </tbody></table>\n  </div>\n</section>\n\n<section id=\"precedencia\">\n  <h2><span class=\"num\">3</span> PrecedÃªncia e parÃªnteses</h2>\n\n  <p>Assim como em aritmÃ©tica, a precedÃªncia determina como uma ER sem parÃªnteses Ã© lida. Da maior para a menor prioridade:</p>\n\n  <table class=\"prec-table\">\n    <tbody><tr><th>Prioridade</th><th>OperaÃ§Ã£o</th><th>Exemplo</th><th>Leitura</th></tr>\n    <tr><td>1 (maior)</td><td>Kleene star <code>*</code></td><td><code>ab*</code></td><td><code>a(b*)</code> â€” a seguido de zero ou mais b's</td></tr>\n    <tr><td>2</td><td>ConcatenaÃ§Ã£o</td><td><code>ab|c</code></td><td><code>(ab)|c</code> â€” \"ab\" ou \"c\"</td></tr>\n    <tr><td>3 (menor)</td><td>UniÃ£o <code>|</code></td><td><code>a|bc*</code></td><td><code>a|(b(c*))</code> â€” \"a\" ou b seguido de c's</td></tr>\n  </tbody></table>\n\n  <div class=\"callout warn\">\n    <strong>Erro clÃ¡ssico:</strong> <code>ab*</code> nÃ£o Ã© \"(ab)*\". O star se aplica apenas ao <code>b</code>. Para a string repetida, use parÃªnteses: <code>(ab)*</code>.\n  </div>\n\n  <h3>Exemplos de anÃ¡lise de precedÃªncia</h3>\n  <div class=\"split\">\n    <div class=\"pane\">\n      <h4>ExpressÃ£o: <span class=\"re\">a|b*c</span></h4>\n      <p>AnÃ¡lise: star primeiro â†’ <code>a | (b*)(c)</code><br>\n      LÃª: \"a\" ou \"qualquer nÂº de b's seguido de um c\"</p>\n    </div>\n    <div class=\"pane\">\n      <h4>ExpressÃ£o: <span class=\"re\">(a|b)*c</span></h4>\n      <p>AnÃ¡lise: parÃªnteses primeiro â†’ <code>((a|b)*)c</code><br>\n      LÃª: \"qualquer sequÃªncia de a's e b's seguida de c\"</p>\n    </div>\n    <div class=\"pane\">\n      <h4>ExpressÃ£o: <span class=\"re\">a(b|c)*d</span></h4>\n      <p>AnÃ¡lise: <code>a ((b|c)*) d</code><br>\n      LÃª: \"a, depois qualquer mix de b's e c's, depois d\"</p>\n    </div>\n    <div class=\"pane\">\n      <h4>ExpressÃ£o: <span class=\"re\">0*(1|Îµ)0*</span></h4>\n      <p>AnÃ¡lise: <code>(0*)(1|Îµ)(0*)</code><br>\n      LÃª: \"zeros, opcionalmente um 1, mais zeros\" = binÃ¡rios com no mÃ¡ximo um '1'</p>\n    </div>\n  </div>\n</section>\n\n<section id=\"exemplos\">\n  <h2><span class=\"num\">4</span> ExpressÃµes regulares e suas linguagens</h2>\n\n  <table>\n    <tbody><tr><th>ER sobre {a,b} ou {0,1}</th><th>Linguagem denotada</th></tr>\n    <tr><td><code>a*b*</code></td><td>Zero ou mais a's seguidos de zero ou mais b's: Îµ, a, b, aa, ab, aab, abbâ€¦</td></tr>\n    <tr><td><code>(a|b)*</code></td><td>Todas as strings sobre {a,b} incluindo Îµ = Î£*</td></tr>\n    <tr><td><code>(a|b)*aba(a|b)*</code></td><td>Strings sobre {a,b} que contÃªm \"aba\" como subpalavra</td></tr>\n    <tr><td><code>b*(ab*)*</code></td><td>Strings sobre {a,b} com nÃºmero par de a's? â€” nÃ£o; esta Ã© Î£*</td></tr>\n    <tr><td><code>(aa)*</code></td><td>Strings de a's com comprimento par: Îµ, aa, aaaa, â€¦</td></tr>\n    <tr><td><code>0*10*</code></td><td>Strings binÃ¡rias com exatamente um '1'</td></tr>\n    <tr><td><code>(0|1)*00(0|1)*</code></td><td>Strings binÃ¡rias que contÃªm \"00\" como subpalavra</td></tr>\n    <tr><td><code>(01|10|11|00)*</code></td><td>Strings binÃ¡rias de comprimento par</td></tr>\n    <tr><td><code>Îµ|a|aa</code></td><td>Strings de a's com comprimento 0, 1 ou 2</td></tr>\n  </tbody></table>\n\n  <h3>Linguagens que NÃƒO sÃ£o regulares â€” e portanto nÃ£o tÃªm ER</h3>\n  <div class=\"callout warn\">\n    <strong>NÃ£o existe ER para:</strong><br>\n    â€¢ <code>{aâ¿bâ¿ | n â‰¥ 0}</code> â€” requer contar<br>\n    â€¢ <code>{ww | w âˆˆ {a,b}*}</code> â€” requer memÃ³ria ilimitada da primeira metade<br>\n    â€¢ <code>{w âˆˆ {a,b}* | w Ã© palÃ­ndromo}</code> â€” requer verificaÃ§Ã£o simÃ©trica<br><br>\n    A prova usa o Lema do Bombeamento (MÃ³dulo 8).\n  </div>\n</section>\n\n<section id=\"testador\">\n  <h2><span class=\"num\">5</span> Testador de ExpressÃµes Regulares</h2>\n\n  <div id=\"re-builder\">\n    <div class=\"rb-header\">\n      <h3>ğŸ”¬ Testador de ER</h3>\n      <span class=\"rb-badge\">Subset do JavaScript RegExp</span>\n    </div>\n    <div class=\"rb-body\">\n\n      <p style=\"font-size:0.85rem; color:var(--muted); margin-bottom:0.8rem;\">\n        Sintaxe suportada: <code>a</code> <code>ab</code> (concat) <code>a|b</code> (uniÃ£o) <code>a*</code> <code>a+</code> <code>a?</code> <code>(ER)</code>.\n        Use <code>Îµ</code> ou deixe campo vazio para string vazia.\n      </p>\n\n      <div style=\"margin-bottom:0.8rem;\">\n        <div style=\"font-size:0.78rem; text-transform:uppercase; letter-spacing:1px; color:var(--muted); margin-bottom:0.4rem;\">Exemplos prontos</div>\n        <div class=\"re-presets\">\n          <button class=\"re-preset\">contÃ©m \"aba\"</button>\n          <button class=\"re-preset\">comprimento par de a's</button>\n          <button class=\"re-preset\">exatamente um 1</button>\n          <button class=\"re-preset\">contÃ©m \"00\"</button>\n          <button class=\"re-preset\">a...d com b's e c's</button>\n          <button class=\"re-preset\">alternÃ¢ncia par</button>\n          <button class=\"re-preset\">comprimento par</button>\n        </div>\n      </div>\n\n      <div class=\"re-input-row\">\n        <label>ER:</label>\n        <input type=\"text\" id=\"re-input\" placeholder=\"ex: (a|b)*aba\" value=\"(a|b)*aba(a|b)*\">\n        <label>String:</label>\n        <input type=\"text\" id=\"str-input\" placeholder=\"ex: babab\">\n        <div class=\"rb-controls\">\n          <button class=\"rb-btn btn-purple\">â–¶ Testar</button>\n          <button class=\"rb-btn btn-sec\">â†º</button>\n        </div>\n      </div>\n\n      <canvas id=\"re-tree-canvas\"></canvas>\n\n      <div id=\"re-status\" class=\"\"></div>\n      <div id=\"re-result\"></div>\n    </div>\n  </div>\n</section>\n\n<section id=\"thompson\">\n  <h2><span class=\"num\">6</span> ConstruÃ§Ã£o de Thompson â€” ER â†’ AFN</h2>\n\n  <p>A <strong>construÃ§Ã£o de Thompson</strong> (1968) converte uma expressÃ£o regular em um AFN com Îµ-transiÃ§Ãµes de forma sistemÃ¡tica, respeitando a estrutura indutiva da ER.</p>\n\n  <p>Cada sub-ER gera um \"fragmento\" de AFN com <strong>exatamente um estado inicial e um estado final</strong>. Os fragmentos sÃ£o depois compostos pelas regras de cada operaÃ§Ã£o.</p>\n\n  <h3>Casos base</h3>\n\n  <div class=\"thompson-wrap\">\n    <div class=\"thompson-header\"><span>ğŸ”µ Casos base da construÃ§Ã£o de Thompson</span></div>\n    <div class=\"thompson-body\">\n      <canvas id=\"tc-base\" class=\"tc\" style=\"height:160px;\"></canvas>\n      <p style=\"font-size:0.82rem; color:var(--muted); text-align:center;\">Esquerda: âˆ… (nenhuma transiÃ§Ã£o). Centro: Îµ (Îµ-transiÃ§Ã£o). Direita: sÃ­mbolo a (transiÃ§Ã£o com a).</p>\n    </div>\n  </div>\n\n  <h3>OperaÃ§Ã£o: UniÃ£o (R|S)</h3>\n\n  <div class=\"thompson-wrap\">\n    <div class=\"thompson-header\"><span>ğŸŸ  Thompson â€” UniÃ£o</span></div>\n    <div class=\"thompson-body\">\n      <canvas id=\"tc-union\" class=\"tc\" style=\"height:180px;\"></canvas>\n      <p style=\"font-size:0.82rem; color:var(--muted); text-align:center;\">Novo q_i e q_f. Îµ de q_i para inÃ­cios de N(R) e N(S). Îµ dos finais de N(R) e N(S) para q_f.</p>\n    </div>\n  </div>\n\n  <h3>OperaÃ§Ã£o: ConcatenaÃ§Ã£o (RS)</h3>\n\n  <div class=\"thompson-wrap\">\n    <div class=\"thompson-header\"><span>ğŸŸ¢ Thompson â€” ConcatenaÃ§Ã£o</span></div>\n    <div class=\"thompson-body\">\n      <canvas id=\"tc-concat\" class=\"tc\" style=\"height:130px;\"></canvas>\n      <p style=\"font-size:0.82rem; color:var(--muted); text-align:center;\">Îµ do estado final de N(R) para o estado inicial de N(S). O estado inicial de N(R) Ã© o inicial do resultado; o final de N(S) Ã© o final.</p>\n    </div>\n  </div>\n\n  <h3>OperaÃ§Ã£o: Kleene Star (R*)</h3>\n\n  <div class=\"thompson-wrap\">\n    <div class=\"thompson-header\"><span>â­ Thompson â€” Kleene Star</span></div>\n    <div class=\"thompson-body\">\n      <canvas id=\"tc-star\" class=\"tc\" style=\"height:160px;\"></canvas>\n      <p style=\"font-size:0.82rem; color:var(--muted); text-align:center;\">Novo q_i (Îµ â†’ qâ‚€ do N(R) e Îµ â†’ q_f). Do final de N(R), Îµ de volta para qâ‚€ de N(R) e Îµ para q_f.</p>\n    </div>\n  </div>\n\n  <h3>Exemplo completo â€” construÃ§Ã£o de Thompson para <span class=\"re\">(a|b)*a</span></h3>\n\n  <div class=\"card\">\n    <strong>DecomposiÃ§Ã£o:</strong><br>\n    1. Ãtomo <code>a</code> â†’ N(a): q0 â†’<sup>a</sup> q1<br>\n    2. Ãtomo <code>b</code> â†’ N(b): q2 â†’<sup>b</sup> q3<br>\n    3. UniÃ£o <code>a|b</code> â†’ N(a|b): novo qi Îµâ†’{q0,q2}, dos finais {q1,q3} Îµâ†’novo qf<br>\n    4. Kleene <code>(a|b)*</code> â†’ N((a|b)*): envolve N(a|b) com loop Îµ<br>\n    5. Ãtomo final <code>a</code> â†’ N(a): qx â†’<sup>a</sup> qy<br>\n    6. ConcatenaÃ§Ã£o <code>(a|b)*a</code>: Îµ do final de N((a|b)*) para inÃ­cio de N(a)<br><br>\n    <strong>Resultado:</strong> AFN com ~10 estados, equivalente ao AFD de 2 estados que aceita \"termina em a\".\n  </div>\n\n  <div class=\"callout tip\">\n    <strong>Propriedade chave da construÃ§Ã£o de Thompson:</strong> o AFN resultante tem no mÃ¡ximo <em>2|R|</em> estados, onde |R| Ã© o nÃºmero de sÃ­mbolos e operadores em R. Cada sÃ­mbolo contribui com 2 estados, cada operaÃ§Ã£o com no mÃ¡ximo 2 estados extras.\n  </div>\n</section>\n\n<section id=\"eliminacao\">\n  <h2><span class=\"num\">7</span> AFD â†’ ER â€” eliminaÃ§Ã£o de estados</h2>\n\n  <p>A conversÃ£o inversa â€” de AFD para ER â€” usa o mÃ©todo de <strong>eliminaÃ§Ã£o de estados</strong> (tambÃ©m chamado de mÃ©todo de Arden ou GNFA). O processo \"remove\" estados intermediÃ¡rios enquanto acumula a linguagem aceita nos rÃ³tulos das transiÃ§Ãµes restantes.</p>\n\n  <h3>GNFA â€” Generalized NFA</h3>\n  <div class=\"card\">\n    Um GNFA Ã© um AFN cujas transiÃ§Ãµes sÃ£o rotuladas por <em>expressÃµes regulares</em> (nÃ£o apenas sÃ­mbolos).<br><br>\n    <strong>Passo 1:</strong> Converter o AFD em GNFA adicionando um novo estado inicial q_i e um novo estado final q_f, com Îµ-transiÃ§Ãµes.<br>\n    <strong>Passo 2:</strong> Eliminar estados intermediÃ¡rios um a um. Ao eliminar o estado q_rip:<br>\n    <code>Î´'(q1, q2) = Î´(q1, q2) | Î´(q1, q_rip) Î´(q_rip, q_rip)* Î´(q_rip, q2)</code><br>\n    <strong>Passo 3:</strong> Quando restar apenas q_i e q_f, a Ãºnica transiÃ§Ã£o restante Ã© a ER para L(M).\n  </div>\n\n  <h3>Exemplo â€” 2 estados para <span class=\"re\">a*b</span></h3>\n  <div class=\"card\">\n    AFD: q0 â†’<sup>a</sup> q0, q0 â†’<sup>b</sup> q1â˜…<br><br>\n    GNFA: qi â†’ q0 â†’ q1 â†’ qf<br><br>\n    Eliminar q0:<br>\n    &nbsp;&nbsp;<code>Î´'(qi, q1) = Î´(qi,q0) Â· Î´(q0,q0)* Â· Î´(q0,q1) = Îµ Â· a* Â· b = a*b</code><br><br>\n    Restar: qi â†’<sup>a*b</sup> qf<br>\n    ER resultante: <code>a*b</code>\n  </div>\n\n  <div class=\"callout ok\">\n    <strong>Complexidade:</strong> o processo de eliminaÃ§Ã£o de n-2 estados (removendo q_i e q_f da contagem) pode gerar uma ER de tamanho exponencial no pior caso. Na prÃ¡tica, a ordem de eliminaÃ§Ã£o afeta o tamanho â€” eliminar estados com muitas transiÃ§Ãµes primeiro geralmente produz ERs maiores.\n  </div>\n</section>\n\n<section id=\"triangulo\">\n  <h2><span class=\"num\">8</span> O triÃ¢ngulo das equivalÃªncias</h2>\n\n  <div class=\"fbox purple\" style=\"font-size:0.95rem; padding: 2rem;\">\n    <span class=\"flabel\">Teorema de Kleene â€” todas as direÃ§Ãµes</span>\n    <div style=\"margin: 1rem 0; font-size:1.05rem; line-height:2.2;\">\n      AFD &nbsp;âŸº&nbsp; AFN &nbsp;âŸº&nbsp; ER\n    </div>\n    <div style=\"font-size:0.82rem; opacity:0.8; text-align:left; max-width:480px; margin:0 auto; font-family:'Segoe UI',sans-serif;\">\n      AFD â†’ AFN: trivial (AFD Ã© caso especial de AFN)<br>\n      AFN â†’ AFD: construÃ§Ã£o de subconjuntos (MÃ³dulo 3)<br>\n      ER â†’ AFN: construÃ§Ã£o de Thompson (este mÃ³dulo)<br>\n      AFD â†’ ER: eliminaÃ§Ã£o de estados / GNFA (este mÃ³dulo)<br>\n      AFN â†’ ER: converta AFNâ†’AFD, depois AFDâ†’ER\n    </div>\n  </div>\n\n  <div class=\"split\">\n    <div class=\"pane\">\n      <h4>Quando usar cada modelo</h4>\n      <p><strong>AFD:</strong> implementaÃ§Ã£o eficiente, anÃ¡lise lÃ©xica, comparaÃ§Ã£o de linguagens</p>\n      <p><strong>AFN:</strong> design de autÃ´matos, prova de fechamento, construÃ§Ã£o modular</p>\n      <p><strong>ER:</strong> especificaÃ§Ã£o de padrÃµes, interface humana, entrada para ferramentas</p>\n    </div>\n    <div class=\"pane\">\n      <h4>Tamanho nos formatos</h4>\n      <p>Seja L uma linguagem regular com AFD mÃ­nimo de n estados:</p>\n      <p>â€¢ AFN equivalente: no mÃ¡ximo n estados (igual)</p>\n      <p>â€¢ ER equivalente: pode ter tamanho exponencial em n</p>\n      <p>â€¢ AFD a partir de ER de tamanho m: pode ter 2<sup>m</sup> estados</p>\n    </div>\n  </div>\n</section>\n\n<section id=\"quiz\">\n  <h2><span class=\"num\">9</span> ExercÃ­cios â€” estilo POSCOMP</h2>\n\n  <div class=\"quiz\">\n    <h3>QuestÃ£o 1</h3>\n    <p>Qual das ERs sobre {a,b} descreve a linguagem de strings que comeÃ§am e terminam com 'a'?</p>\n    <div class=\"options\" id=\"q1\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"A\"> A) <code>a(a|b)*a</code></label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"B\"> B) <code>a(a|b)*a | a</code></label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"C\"> C) <code>a(a|b)*</code></label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"D\"> D) <code>(a|b)*a(a|b)*</code></label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q1\" data-answer-key=\"B\" data-explanation-id=\"e1\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q1-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>QuestÃ£o 2</h3>\n    <p>A expressÃ£o regular <code>(ab)*|Îµ</code> Ã© equivalente a qual das seguintes?</p>\n    <div class=\"options\" id=\"q2\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"A\"> A) <code>(ab)+</code></label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"B\"> B) <code>(ab)*</code></label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"C\"> C) <code>a*b*</code></label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"D\"> D) <code>(a|b)*</code></label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q2\" data-answer-key=\"B\" data-explanation-id=\"e2\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q2-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>QuestÃ£o 3</h3>\n    <p>Na construÃ§Ã£o de Thompson para a ER <code>R|S</code>, quantos estados sÃ£o criados alÃ©m dos estados de N(R) e N(S)?</p>\n    <div class=\"options\" id=\"q3\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"A\"> A) 0 â€” reutiliza estados existentes</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"B\"> B) 1 â€” apenas o novo estado inicial</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"C\"> C) 2 â€” um novo estado inicial e um novo estado final</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"D\"> D) 4 â€” dois de entrada e dois de saÃ­da</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q3\" data-answer-key=\"C\" data-explanation-id=\"e3\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q3-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>QuestÃ£o 4 â€” POSCOMP nÃ­vel difÃ­cil</h3>\n    <p>Qual das linguagens abaixo Ã© descrita pela ER <code>1(0|1)*0</code> sobre {0,1}?</p>\n    <div class=\"options\" id=\"q4\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"A\"> A) Strings binÃ¡rias que comeÃ§am com 1 e terminam com 0</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"B\"> B) Strings binÃ¡rias com exatamente um 1 e um 0</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"C\"> C) Strings binÃ¡rias de comprimento par que comeÃ§am com 1</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"D\"> D) Strings binÃ¡rias cujo valor em binÃ¡rio Ã© par</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q4\" data-answer-key=\"A\" data-explanation-id=\"e4\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q4-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>QuestÃ£o 5</h3>\n    <p>Seja R = <code>a*</code>. Qual das afirmaÃ§Ãµes sobre L(R) Ã© FALSA?</p>\n    <div class=\"options\" id=\"q5\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"A\"> A) Îµ âˆˆ L(R)</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"B\"> B) \"aaa\" âˆˆ L(R)</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"C\"> C) L(R) Ã© infinita</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"D\"> D) \"b\" âˆˆ L(R)</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q5\" data-answer-key=\"D\" data-explanation-id=\"e5\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q5-res\"></div>\n  </div>\n</section>\n\n<section id=\"resumo\">\n  <h2><span class=\"num\">10</span> Resumo do mÃ³dulo</h2>\n\n  <div class=\"summary\">\n    <h3>O que vocÃª agora domina:</h3>\n    <div class=\"row\">ERs sÃ£o definidas indutivamente com âˆ…, Îµ, sÃ­mbolos do alfabeto, uniÃ£o, concatenaÃ§Ã£o e Kleene star.</div>\n    <div class=\"row\">PrecedÃªncia: * &gt; concatenaÃ§Ã£o &gt; | (mesmo que exponenciaÃ§Ã£o &gt; multiplicaÃ§Ã£o &gt; adiÃ§Ã£o).</div>\n    <div class=\"row\">Identidades: âˆ…* = Îµ, ÎµR = R, âˆ…R = âˆ…, R** = R*.</div>\n    <div class=\"row\">Teorema de Kleene: ER, AFD e AFN tÃªm o mesmo poder expressivo â€” linguagens regulares.</div>\n    <div class=\"row\">Thompson: ER â†’ AFN em O(|R|) estados. Cada operaÃ§Ã£o tem uma construÃ§Ã£o canÃ´nica com 1 entrada e 1 saÃ­da.</div>\n    <div class=\"row\">GNFA/eliminaÃ§Ã£o de estados: AFD â†’ ER removendo estados intermediÃ¡rios.</div>\n    <div class=\"row\">O triÃ¢ngulo estÃ¡ completo: qualquer dos trÃªs formatos pode ser convertido para qualquer outro.</div>\n  </div>\n\n  <h3>O que vem no prÃ³ximo mÃ³dulo</h3>\n  <div class=\"card\">\n    O MÃ³dulo 7 apresenta as <strong>GramÃ¡ticas Livres de Contexto (GLCs)</strong> â€” o prÃ³ximo nÃ­vel da hierarquia de Chomsky. VocÃª verÃ¡ como GLCs descrevem linguagens que autÃ´matos finitos nÃ£o conseguem reconhecer, como {aâ¿bâ¿}, e como os AutÃ´matos de Pilha (PDAs) sÃ£o o equivalente computacional das GLCs.\n  </div>\n</section>"
}
