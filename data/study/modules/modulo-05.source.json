{
  "header": {
    "badge": "Módulo 5 de 9",
    "title": "Minimização de AFD",
    "subtitle": "Encontre o menor AFD possível para uma linguagem — e prove que ele é único.",
    "meta": [
      "~55 min",
      "Nível: Intermediário-Avançado",
      "Algoritmo passo a passo interativo"
    ],
    "progressLabel": "Módulo 5 de 9 — Minimização"
  },
  "navLinks": [
    {
      "id": "motivacao",
      "label": "Motivação"
    },
    {
      "id": "equivalencia",
      "label": "Equivalência"
    },
    {
      "id": "distinguivel",
      "label": "Distinguível"
    },
    {
      "id": "algoritmo",
      "label": "Algoritmo"
    },
    {
      "id": "exemplo",
      "label": "Exemplo"
    },
    {
      "id": "simulador",
      "label": "Simulador"
    },
    {
      "id": "unicidade",
      "label": "Unicidade"
    },
    {
      "id": "nerode",
      "label": "Myhill-Nerode"
    },
    {
      "id": "quiz",
      "label": "Exercícios"
    },
    {
      "id": "resumo",
      "label": "Resumo"
    }
  ],
  "html": "<section id=\"motivacao\">\n  <h2><span class=\"num\">1</span> Por que minimizar?</h2>\n\n  <p>A construção de subconjuntos (Módulo 3) pode gerar AFDs com estados redundantes. A conversão de expressões regulares (Módulo 6) também. Dois AFDs podem reconhecer exatamente a mesma linguagem mas ter números de estados diferentes.</p>\n\n  <p>A <strong>minimização</strong> encontra o AFD com o menor número possível de estados para uma dada linguagem. Isso importa por:</p>\n\n  <div class=\"split\">\n    <div class=\"pane\">\n      <h4>Eficiência prática</h4>\n      <p>Menos estados = menos memória em implementações de compiladores, analisadores léxicos e protocolos. Um AFD mínimo é o \"kernel\" irredutível da linguagem.</p>\n    </div>\n    <div class=\"pane\">\n      <h4>Comparação de linguagens</h4>\n      <p>Dois AFDs reconhecem a mesma linguagem se e somente se seus AFDs mínimos são isomorfos. A minimização é o teste definitivo de igualdade entre linguagens regulares.</p>\n    </div>\n  </div>\n\n  <div class=\"callout key\">\n    <strong>Teorema central:</strong> para cada linguagem regular existe um AFD mínimo único (a menos de renomeação de estados). A minimização não é apenas uma otimização — ela revela a estrutura essencial da linguagem.\n  </div>\n</section>\n\n<section id=\"equivalencia\">\n  <h2><span class=\"num\">2</span> Estados equivalentes</h2>\n\n  <p>Dois estados são <strong>equivalentes</strong> se a máquina se comporta identicamente a partir de ambos — ou seja, para qualquer string w, a máquina aceita w em um se e somente se aceita w no outro.</p>\n\n  <div class=\"fbox amber\">\n    <span class=\"flabel\">Definição — estados equivalentes</span>\n    p ≡ q &nbsp;⟺&nbsp; ∀w ∈ Σ* : δ*(p, w) ∈ F ↔ δ*(q, w) ∈ F\n    <span class=\"fsub\">p e q são indistinguíveis: nenhuma string os separa</span>\n  </div>\n\n  <p>Se p ≡ q, eles podem ser <strong>fundidos</strong> em um único estado sem alterar a linguagem reconhecida. O AFD mínimo é aquele onde nenhum par de estados distintos é equivalente.</p>\n\n  <h3>Equivalência é uma relação de equivalência</h3>\n  <div class=\"card\">\n    <table>\n      <tbody><tr><th>Propriedade</th><th>Prova</th></tr>\n      <tr><td>Reflexiva: p ≡ p</td><td>Trivial — um estado concorda consigo mesmo</td></tr>\n      <tr><td>Simétrica: p ≡ q ⟹ q ≡ p</td><td>A definição é simétrica em p e q</td></tr>\n      <tr><td>Transitiva: p ≡ q e q ≡ r ⟹ p ≡ r</td><td>Se p e q concordam, e q e r concordam, então p e r concordam</td></tr>\n    </tbody></table>\n    <p style=\"margin-top:0.5rem; font-size:0.88rem; color:var(--muted);\">Como é uma relação de equivalência, ela particiona Q em classes de equivalência. O AFD mínimo tem um estado por classe.</p>\n  </div>\n</section>\n\n<section id=\"distinguivel\">\n  <h2><span class=\"num\">3</span> Estados distinguíveis</h2>\n\n  <p>É mais fácil trabalhar com a noção oposta: dois estados são <strong>distinguíveis</strong> se existe alguma string que os separa.</p>\n\n  <div class=\"fbox amber\">\n    <span class=\"flabel\">Definição — estados distinguíveis</span>\n    p e q são distinguíveis &nbsp;⟺&nbsp; ∃w ∈ Σ* : δ*(p,w) ∈ F &nbsp;⊕&nbsp; δ*(q,w) ∈ F\n    <span class=\"fsub\">A string w é uma \"testemunha\" da distinguibilidade de p e q</span>\n  </div>\n\n  <h3>Casos base de distinguibilidade</h3>\n  <div class=\"callout ok\">\n    <strong>Base:</strong> todo par (final, não-final) é distinguido pela string vazia ε.<br>\n    Prova: δ*(p, ε) = p ∈ F, mas δ*(q, ε) = q ∉ F. A testemunha é ε.\n  </div>\n\n  <h3>Passo indutivo</h3>\n  <div class=\"card\">\n    Se p e q são distinguíveis por w, então para qualquer símbolo a:<br>\n    os estados r = δ(r₀, a) e s = δ(s₀, a) tais que δ*(r, w) = p e δ*(s, w) = q<br>\n    são distinguíveis pela string <strong>aw</strong>.<br><br>\n    Equivalentemente: se <code>δ(p, a)</code> e <code>δ(q, a)</code> são distinguíveis, então p e q também são distinguíveis (pela string <em>a</em> concatenada com a testemunha dos sucessores).\n  </div>\n</section>\n\n<section id=\"algoritmo\">\n  <h2><span class=\"num\">4</span> Algoritmo de particionamento (Table-Filling)</h2>\n\n  <p>O algoritmo mais clássico para minimização é o <strong>algoritmo de preenchimento de tabela</strong> (também chamado de algoritmo de Hopcroft simplificado ou de marcação). Ele identifica todos os pares distinguíveis de forma sistemática.</p>\n\n  <div class=\"card\">\n    <strong>Entrada:</strong> AFD M completo, sem estados inacessíveis<br>\n    <strong>Saída:</strong> tabela triangular onde cada célula (p, q) está marcada se p e q são distinguíveis<br><br>\n\n    <strong>Passo 1 — Remoção de estados inacessíveis:</strong><br>\n    Remova estados que não são alcançáveis a partir de q₀ (busca em largura/profundidade).<br><br>\n\n    <strong>Passo 2 — Base (inicialização):</strong><br>\n    Marque como distinguíveis todos os pares (p, q) onde um é final e o outro não.<br><br>\n\n    <strong>Passo 3 — Propagação (iterar até estabilizar):</strong><br>\n    Para cada par não-marcado (p, q) e para cada símbolo a ∈ Σ:<br>\n    &nbsp;&nbsp;&nbsp;Se (δ(p,a), δ(q,a)) já está marcado → marque (p, q) também.<br><br>\n\n    <strong>Passo 4 — Fusão:</strong><br>\n    Pares não-marcados ao final são equivalentes. Funda-os em um único estado.\n  </div>\n\n  <div class=\"callout tip\">\n    <strong>Por que o algoritmo termina?</strong> A cada iteração do passo 3, ou marcamos pelo menos um par novo, ou paramos. Como há no máximo |Q|² pares e cada marcação é permanente, o algoritmo termina em no máximo |Q|² iterações.\n  </div>\n\n  <h3>Algoritmo alternativo — Particionamento iterativo</h3>\n  <div class=\"card\">\n    Inicia com a partição P = {F, Q\\F} (estados finais vs. não-finais).<br><br>\n    Itera: para cada classe C e símbolo a, verifica se todos os estados de C vão para a mesma classe ao ler a.<br>\n    Se não: divide C nas sub-classes que vão para classes diferentes.<br><br>\n    Para quando nenhuma classe pode mais ser dividida.\n  </div>\n</section>\n\n<section id=\"exemplo\">\n  <h2><span class=\"num\">5</span> Exemplo completo — passo a passo</h2>\n\n  <p>Vamos minimizar um AFD com 6 estados sobre Σ = {a, b}. A tabela de transição é:</p>\n\n  <table>\n    <tbody><tr><th>Estado</th><th>Lê a</th><th>Lê b</th><th>Tipo</th></tr>\n    <tr><td><strong>→ A</strong></td><td>B</td><td>C</td><td>inicial</td></tr>\n    <tr><td>B</td><td>A</td><td>D</td><td>—</td></tr>\n    <tr><td>C</td><td>E</td><td>F</td><td>—</td></tr>\n    <tr><td>★ D</td><td>E</td><td>F</td><td>final</td></tr>\n    <tr><td>★ E</td><td>E</td><td>F</td><td>final</td></tr>\n    <tr><td>★ F</td><td>F</td><td>F</td><td>final</td></tr>\n  </tbody></table>\n\n  <h3>Passo 1 — Verificar acessibilidade</h3>\n  <p>A partir de A: A→B, A→C, B→D, C→E, C→F, D→E, D→F, E→F. Todos os 6 estados são acessíveis.</p>\n\n  <h3>Passo 2 — Inicialização da tabela (base)</h3>\n  <p>Finais = {D, E, F}. Não-finais = {A, B, C}. Marcamos com ✗ todos os pares (final, não-final):</p>\n\n  <div class=\"dist-table-wrap\">\n    <table class=\"dist-table\">\n      <tbody><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr>\n      <tr><th>B</th><td class=\"dist-dash\">—</td><td></td><td></td><td></td><td></td></tr>\n      <tr><th>C</th><td class=\"dist-dash\">—</td><td class=\"dist-dash\">—</td><td></td><td></td><td></td></tr>\n      <tr><th>D</th><td class=\"dist-step1\">✗₀</td><td class=\"dist-step1\">✗₀</td><td class=\"dist-step1\">✗₀</td><td></td><td></td></tr>\n      <tr><th>E</th><td class=\"dist-step1\">✗₀</td><td class=\"dist-step1\">✗₀</td><td class=\"dist-step1\">✗₀</td><td class=\"dist-dash\">—</td><td></td></tr>\n      <tr><th>F</th><td class=\"dist-step1\">✗₀</td><td class=\"dist-step1\">✗₀</td><td class=\"dist-step1\">✗₀</td><td class=\"dist-dash\">—</td><td class=\"dist-dash\">—</td></tr>\n    </tbody></table>\n  </div>\n  <p style=\"font-size:0.85rem; color:var(--muted);\">✗₀ = distinguido na base (por ε). — = mesma classe (mesmo tipo).</p>\n\n  <h3>Passo 3 — Propagação</h3>\n  <p>Verificamos pares não-marcados: (A,B), (A,C), (B,C), (D,E), (D,F), (E,F).</p>\n\n  <div class=\"card\">\n    <strong>Par (D,E):</strong> δ(D,a)=E, δ(E,a)=E → par (E,E), não marcado. δ(D,b)=F, δ(E,b)=F → (F,F), não marcado. → D e E não distinguidos ainda.<br><br>\n    <strong>Par (D,F):</strong> δ(D,a)=E, δ(F,a)=F → par (E,F), não marcado. δ(D,b)=F, δ(F,b)=F → (F,F). → D e F não distinguidos ainda.<br><br>\n    <strong>Par (E,F):</strong> δ(E,a)=E, δ(F,a)=F → (E,F) — próprio par! δ(E,b)=F, δ(F,b)=F → (F,F). → E e F não distinguidos.<br><br>\n    <strong>Par (A,B):</strong> δ(A,a)=B, δ(B,a)=A → (B,A) = (A,B), não marcado. δ(A,b)=C, δ(B,b)=D → (C,D), marcado! → (A,B) fica marcado ✗₁.<br><br>\n    <strong>Par (A,C):</strong> δ(A,a)=B, δ(C,a)=E → (B,E), marcado (B é não-final, E é final)! → (A,C) fica marcado ✗₁.<br><br>\n    <strong>Par (B,C):</strong> δ(B,a)=A, δ(C,a)=E → (A,E), marcado! → (B,C) fica marcado ✗₁.\n  </div>\n\n  <h3>Tabela final</h3>\n  <div class=\"dist-table-wrap\">\n    <table class=\"dist-table\">\n      <tbody><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr>\n      <tr><th>B</th><td class=\"dist-step2\">✗₁</td><td></td><td></td><td></td><td></td></tr>\n      <tr><th>C</th><td class=\"dist-step2\">✗₁</td><td class=\"dist-step2\">✗₁</td><td></td><td></td><td></td></tr>\n      <tr><th>D</th><td class=\"dist-step1\">✗₀</td><td class=\"dist-step1\">✗₀</td><td class=\"dist-step1\">✗₀</td><td></td><td></td></tr>\n      <tr><th>E</th><td class=\"dist-step1\">✗₀</td><td class=\"dist-step1\">✗₀</td><td class=\"dist-step1\">✗₀</td><td class=\"dist-eq\">≡</td><td></td></tr>\n      <tr><th>F</th><td class=\"dist-step1\">✗₀</td><td class=\"dist-step1\">✗₀</td><td class=\"dist-step1\">✗₀</td><td class=\"dist-eq\">≡</td><td class=\"dist-eq\">≡</td></tr>\n    </tbody></table>\n  </div>\n  <p style=\"font-size:0.85rem; color:var(--muted);\">✗₀ = base | ✗₁ = propagação | ≡ = equivalentes (não distinguidos)</p>\n\n  <h3>Passo 4 — Fusão</h3>\n  <p>Classes de equivalência: <strong>{A}</strong>, <strong>{B}</strong>, <strong>{C}</strong>, <strong>{D, E, F}</strong>.</p>\n\n  <div class=\"partition\">\n    <div class=\"class nonfinal\">{A}</div>\n    <div class=\"class nonfinal\">{B}</div>\n    <div class=\"class nonfinal\">{C}</div>\n    <div class=\"class final\">{D, E, F} → estado único \"DEF\"</div>\n  </div>\n\n  <div class=\"card\">\n    <strong>AFD mínimo resultante (4 estados):</strong>\n    <table style=\"margin-top:0.7rem;\">\n      <tbody><tr><th>Estado</th><th>Lê a</th><th>Lê b</th><th>Tipo</th></tr>\n      <tr><td><strong>→ A</strong></td><td>B</td><td>C</td><td>inicial</td></tr>\n      <tr><td>B</td><td>A</td><td>DEF</td><td>—</td></tr>\n      <tr><td>C</td><td>DEF</td><td>DEF</td><td>—</td></tr>\n      <tr><td class=\"hl\">★ DEF</td><td>DEF</td><td>DEF</td><td>final</td></tr>\n    </tbody></table>\n    <p style=\"font-size:0.88rem; color:var(--muted); margin-top:0.5rem;\">D, E e F se fundiram: todos têm o mesmo comportamento futuro — qualquer string lida a partir deles termina em DEF (final).</p>\n  </div>\n</section>\n\n<section id=\"simulador\">\n  <h2><span class=\"num\">6</span> Simulador de minimização interativo</h2>\n\n  <div id=\"minimizer\">\n    <div class=\"min-header\">\n      <h3>⚙️ Minimizador de AFD — Algoritmo de Partições</h3>\n      <span class=\"min-badge\">Passo a passo</span>\n    </div>\n    <div class=\"min-body\">\n\n      <div class=\"preset-row\">\n        <button class=\"preset-btn active\" data-preset-id=\"exemplo5\">Exemplo do módulo (6→4)</button>\n        <button class=\"preset-btn\" data-preset-id=\"redundante\">Com redundâncias (5→3)</button>\n        <button class=\"preset-btn\" data-preset-id=\"jaminimo\">Já mínimo (3 estados)</button>\n      </div>\n\n      <div class=\"min-canvases\">\n        <div class=\"min-canvas-wrap\">\n          <div class=\"min-canvas-label\">AFD original</div>\n          <canvas id=\"canvas-original\" class=\"min-canvas\"></canvas>\n        </div>\n        <div class=\"min-canvas-wrap\">\n          <div class=\"min-canvas-label\">AFD mínimo</div>\n          <canvas id=\"canvas-minimal\" class=\"min-canvas\"></canvas>\n        </div>\n      </div>\n\n      <div class=\"partition-display\">\n        <div class=\"pd-label\">Partição atual</div>\n        <div id=\"pd-classes\" class=\"pd-classes\"><span style=\"color:var(--muted);font-size:0.85rem;\">Clique em Iniciar para começar.</span></div>\n      </div>\n\n      <div class=\"min-controls\">\n        <button class=\"min-btn btn-amber\">▶ Iniciar</button>\n        <button class=\"min-btn btn-sec\">⏭ Próxima iteração</button>\n        <button class=\"min-btn btn-green\">⚡ Minimizar tudo</button>\n        <button class=\"min-btn btn-sec\">↺ Resetar</button>\n      </div>\n\n      <div id=\"min-log\" class=\"min-log\"><span style=\"color:var(--muted);\">Selecione um AFD e clique em Iniciar.</span></div>\n    </div>\n  </div>\n</section>\n\n<section id=\"unicidade\">\n  <h2><span class=\"num\">7</span> Unicidade do AFD mínimo</h2>\n\n  <div class=\"fbox amber\">\n    <span class=\"flabel\">Teorema</span>\n    Para cada linguagem regular L, existe um único AFD mínimo M* que reconhece L (a menos de isomorfismo).\n  </div>\n\n  <p>Isso significa que independente de qual AFD você comece, aplicando a minimização chegará sempre ao mesmo resultado (com os estados possivelmente nomeados diferente). Dois AFDs reconhecem a mesma linguagem se e somente se seus mínimos são isomorfos.</p>\n\n  <h3>Consequência prática: teste de igualdade</h3>\n  <div class=\"card\">\n    <strong>Como decidir se L(M₁) = L(M₂)?</strong><br><br>\n    1. Minimize M₁ → M₁*<br>\n    2. Minimize M₂ → M₂*<br>\n    3. Verifique se M₁* e M₂* são isomorfos (mesmo número de estados, mesmas transições a menos de renomeação)<br><br>\n    Se isomorfos → L(M₁) = L(M₂). Caso contrário → linguagens diferentes.\n  </div>\n\n  <h3>Estados inacessíveis vs. estados equivalentes</h3>\n  <div class=\"split\">\n    <div class=\"pane\">\n      <h4>Estados inacessíveis</h4>\n      <p>Não são alcançáveis a partir de q₀. Removê-los não altera L(M). <strong>Devem ser removidos antes</strong> do algoritmo de minimização.</p>\n    </div>\n    <div class=\"pane\">\n      <h4>Estados equivalentes (indistinguíveis)</h4>\n      <p>São alcançáveis mas têm o mesmo comportamento futuro. São fundidos pelo algoritmo. Essa é a redução essencial.</p>\n    </div>\n  </div>\n</section>\n\n<section id=\"nerode\">\n  <h2><span class=\"num\">8</span> Teorema de Myhill-Nerode</h2>\n\n  <p>O teorema de Myhill-Nerode fornece uma caracterização algébrica das linguagens regulares que também determina o número mínimo de estados de qualquer AFD para L.</p>\n\n  <div class=\"fbox amber\">\n    <span class=\"flabel\">Relação de Myhill-Nerode</span>\n    x ≡_L y &nbsp;⟺&nbsp; ∀z ∈ Σ* : (xz ∈ L ↔ yz ∈ L)\n    <span class=\"fsub\">x e y são indistinguíveis por L: qualquer sufixo z os classifica da mesma forma</span>\n  </div>\n\n  <div class=\"fbox amber\" style=\"margin-top:0.5rem;\">\n    <span class=\"flabel\">Teorema de Myhill-Nerode</span>\n    L é regular &nbsp;⟺&nbsp; a relação ≡_L tem índice finito (número finito de classes)\n    <span class=\"fsub\">O número de classes de ≡_L = número de estados do AFD mínimo para L</span>\n  </div>\n\n  <h3>Classes de equivalência de Myhill-Nerode = estados do AFD mínimo</h3>\n  <div class=\"card\">\n    Cada classe de ≡_L corresponde a um estado do AFD mínimo. A classe de x é \"tudo que a máquina lembrou ao processar x\".<br><br>\n    <strong>Exemplo — L = strings binárias terminando em \"01\":</strong><br>\n    <table style=\"margin-top:0.7rem; font-size:0.88rem;\">\n      <tbody><tr><th>Classe (≡_L)</th><th>Strings representativas</th><th>Comportamento</th></tr>\n      <tr><td>[ε] = {ε, 1, 11, 111, ...}</td><td>Terminam em 1 ou são vazias</td><td>Estado q0</td></tr>\n      <tr><td>[0] = {0, 10, 110, ...}</td><td>Terminam em 0 (não precedido por \"0→1\")</td><td>Estado q1</td></tr>\n      <tr><td>[01] = {01, 001, 101, ...}</td><td>Terminam em \"01\"</td><td>Estado q2 (final)</td></tr>\n    </tbody></table>\n    <p style=\"font-size:0.85rem; color:var(--muted); margin-top:0.4rem;\">3 classes → AFD mínimo tem 3 estados (o mesmo do Módulo 2!).</p>\n  </div>\n\n  <div class=\"callout tip\">\n    <strong>Uso do teorema em provas de não-regularidade:</strong> se conseguirmos mostrar que ≡_L tem infinitas classes, então L não é regular — sem precisar do Lema do Bombeamento. Isso é útil para linguagens como {aⁿbⁿ}, onde cada prefixo \"aⁿ\" cria uma classe nova.\n  </div>\n</section>\n\n<section id=\"quiz\">\n  <h2><span class=\"num\">9</span> Exercícios — estilo POSCOMP</h2>\n\n  <div class=\"quiz\">\n    <h3>Questão 1</h3>\n    <p>Um AFD M tem 5 estados: q0 (inicial), q1, q2 (finais), q3, q4. Após a aplicação do algoritmo de minimização, q0 ≡ q3 e q1 ≡ q4. O AFD mínimo tem quantos estados?</p>\n    <div class=\"options\" id=\"q1\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"A\"> A) 5</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"B\"> B) 4</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"C\"> C) 3</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"D\"> D) 2</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q1\" data-answer-key=\"C\" data-explanation-id=\"e1\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q1-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Questão 2</h3>\n    <p>No algoritmo de Table-Filling, a base marca como distinguíveis os pares:</p>\n    <div class=\"options\" id=\"q2\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"A\"> A) Pares com estados que têm transições diferentes</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"B\"> B) Pares onde ambos são estados finais</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"C\"> C) Pares onde um é final e o outro não é final</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"D\"> D) Pares onde os estados têm o mesmo nome</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q2\" data-answer-key=\"C\" data-explanation-id=\"e2\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q2-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Questão 3 — Myhill-Nerode</h3>\n    <p>Pela teoria de Myhill-Nerode, a linguagem L = {aⁿbⁿ | n ≥ 0} (número igual de a's seguido de b's):</p>\n    <div class=\"options\" id=\"q3\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"A\"> A) É regular, com AFD mínimo de 3 estados</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"B\"> B) É regular, mas seu AFD mínimo tem infinitos estados</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"C\"> C) Não é regular, pois a relação ≡_L tem infinitas classes</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"D\"> D) Não é regular, pois não pode ser descrita por expressão regular simples</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q3\" data-answer-key=\"C\" data-explanation-id=\"e3\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q3-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Questão 4</h3>\n    <p>Dois AFDs M₁ e M₂ reconhecem a mesma linguagem se e somente se:</p>\n    <div class=\"options\" id=\"q4\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"A\"> A) Têm o mesmo número de estados</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"B\"> B) Têm a mesma tabela de transição</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"C\"> C) Seus AFDs mínimos são isomorfos</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"D\"> D) Ambos aceitam a string vazia ε</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q4\" data-answer-key=\"C\" data-explanation-id=\"e4\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q4-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Questão 5 — POSCOMP nível difícil</h3>\n    <p>Um AFD tem 8 estados e seu AFD mínimo tem 5 estados. Qual é a afirmação correta sobre o processo de minimização?</p>\n    <div class=\"options\" id=\"q5\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"A\"> A) Exatamente 3 estados foram removidos por serem inacessíveis</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"B\"> B) Exatamente 3 pares de estados foram fundidos um a um</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"C\"> C) A redução de 3 estados pode ter ocorrido por remoção de inacessíveis, fusão de equivalentes, ou ambos — não há como saber só pelo número</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"D\"> D) O AFD original tinha necessariamente 3 estados equivalentes entre si</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q5\" data-answer-key=\"C\" data-explanation-id=\"e5\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q5-res\"></div>\n  </div>\n</section>\n\n<section id=\"resumo\">\n  <h2><span class=\"num\">10</span> Resumo do módulo</h2>\n\n  <div class=\"summary\">\n    <h3>O que você agora domina:</h3>\n    <div class=\"row\">Estados equivalentes: p ≡ q se qualquer string os classifica da mesma forma a partir de ambos.</div>\n    <div class=\"row\">Distinguibilidade: p e q distinguíveis se existe w tal que δ*(p,w) ∈ F ⊕ δ*(q,w) ∈ F.</div>\n    <div class=\"row\">Base: todo par (final, não-final) é distinguido por ε.</div>\n    <div class=\"row\">Propagação: se δ(p,a) e δ(q,a) são distinguíveis, então p e q são distinguíveis por \"a + testemunha\".</div>\n    <div class=\"row\">AFD mínimo: remova inacessíveis, aplique table-filling, funda as classes equivalentes.</div>\n    <div class=\"row\">O AFD mínimo é único (a menos de isomorfismo) — é a estrutura canônica da linguagem.</div>\n    <div class=\"row\">Myhill-Nerode: L é regular ⟺ ≡_L tem índice finito; o índice = número de estados do mínimo.</div>\n  </div>\n\n  <h3>O que vem no próximo módulo</h3>\n  <div class=\"card\">\n    O Módulo 6 apresenta as <strong>Expressões Regulares</strong> — a notação algébrica para linguagens regulares. Você verá a construção de Thompson (ER → AFN) e a eliminação de estados (AFD → ER), completando o triângulo de equivalências: AFD ↔ AFN ↔ ER.\n  </div>\n</section>"
}
