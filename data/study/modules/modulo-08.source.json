{
  "header": {
    "badge": "M√≥dulo 8 de 9 ‚Äî Final",
    "title": "Bombeamento, Chomsky e Computabilidade",
    "subtitle": "Prove que linguagens n√£o s√£o regulares (ou n√£o s√£o livres de contexto), entenda a hierarquia completa e conhe√ßa os limites fundamentais da computa√ß√£o.",
    "meta": [
      "~70 min",
      "N√≠vel: Avan√ßado",
      "Simulador do Lema do Bombeamento"
    ],
    "progressLabel": "M√≥dulo 8 de 9 ‚Äî Conclus√£o do curr√≠culo"
  },
  "navLinks": [
    {
      "id": "lema",
      "label": "Lema"
    },
    {
      "id": "prova",
      "label": "Prova"
    },
    {
      "id": "simulador",
      "label": "Simulador"
    },
    {
      "id": "llc",
      "label": "LLC"
    },
    {
      "id": "chomsky",
      "label": "Chomsky"
    },
    {
      "id": "mt",
      "label": "Turing"
    },
    {
      "id": "decidibilidade",
      "label": "Decidibilidade"
    },
    {
      "id": "parada",
      "label": "Parada"
    },
    {
      "id": "quiz",
      "label": "Exerc√≠cios"
    },
    {
      "id": "resumo",
      "label": "Resumo"
    }
  ],
  "html": "<section id=\"lema\">\n  <h2><span class=\"num\">1</span> Lema do Bombeamento ‚Äî linguagens regulares</h2>\n\n  <p>O Lema do Bombeamento √© a ferramenta padr√£o para provar que uma linguagem <em>n√£o</em> √© regular. Ele captura uma propriedade que <em>toda</em> linguagem regular deve satisfazer ‚Äî se uma linguagem viola essa propriedade, n√£o pode ser regular.</p>\n\n  <p>A intui√ß√£o: se uma linguagem regular √© reconhecida por um AFD com <em>p</em> estados e uma string tem comprimento ‚â• p, ent√£o por princ√≠pio da casa de pombos o AFD deve revisitar algum estado. Esse \"loop\" pode ser repetido arbitrariamente ‚Äî bombeado.</p>\n\n  <div class=\"fbox red\">\n    <span class=\"flabel\">Lema do Bombeamento ‚Äî Linguagens Regulares</span>\n    Se L √© regular, ent√£o existe p ‚â• 1 (comprimento de bombeamento) tal que:<br>\n    toda string w ‚àà L com |w| ‚â• p pode ser escrita como w = xyz onde:<br><br>\n    <span style=\"text-align:left; display:block; max-width:400px; margin:0.7rem auto 0; font-family:'Segoe UI',sans-serif; font-size:0.92rem;\">\n      (1) &nbsp;|y| ‚â• 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(y √© n√£o-vazio)<br>\n      (2) &nbsp;|xy| ‚â§ p &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x e y est√£o nos primeiros p s√≠mbolos)<br>\n      (3) &nbsp;‚àÄi ‚â• 0: xy<sup>i</sup>z ‚àà L &nbsp;(y pode ser bombeado qualquer n√∫mero de vezes)\n    </span>\n    <span class=\"fsub\">A parte y corresponde ao \"loop\" no AFD. Pode ser repetida (bombeada) sem sair da linguagem.</span>\n  </div>\n\n  <h3>Visualiza√ß√£o da decomposi√ß√£o xyz</h3>\n\n  <div class=\"decomp\">\n    <div class=\"decomp-part dp-u\"><span class=\"part-label\">x</span><span class=\"part-name\">prefixo</span></div>\n    <div class=\"decomp-part dp-v\" style=\"border-left:2px dashed #eab308; border-right:2px dashed #eab308;\"><span class=\"part-label\">y</span><span class=\"part-name\">loop</span></div>\n    <div class=\"decomp-part dp-z\"><span class=\"part-label\">z</span><span class=\"part-name\">sufixo</span></div>\n  </div>\n\n  <div style=\"display:flex; gap:0.4rem; flex-direction:column; margin:0.5rem 0 1rem;\">\n    <div class=\"decomp\">\n      <div class=\"decomp-part dp-u\"><span class=\"part-label\">x</span></div>\n      <div class=\"decomp-part dp-z\" style=\"font-style:italic; color:var(--muted);\"><span class=\"part-label\" style=\"font-size:0.95rem;\">z &nbsp;(y bombeado 0√ó)</span></div>\n    </div>\n    <div class=\"decomp\">\n      <div class=\"decomp-part dp-u\"><span class=\"part-label\">x</span></div>\n      <div class=\"decomp-part dp-v\"><span class=\"part-label\">y</span></div>\n      <div class=\"decomp-part dp-z\"><span class=\"part-label\">z &nbsp;(i=1, original)</span></div>\n    </div>\n    <div class=\"decomp\">\n      <div class=\"decomp-part dp-u\"><span class=\"part-label\">x</span></div>\n      <div class=\"decomp-part dp-v\"><span class=\"part-label\">y</span></div>\n      <div class=\"decomp-part dp-v\"><span class=\"part-label\">y</span></div>\n      <div class=\"decomp-part dp-z\"><span class=\"part-label\">z &nbsp;(i=2)</span></div>\n    </div>\n    <div class=\"decomp\">\n      <div class=\"decomp-part dp-u\"><span class=\"part-label\">x</span></div>\n      <div class=\"decomp-part dp-v\"><span class=\"part-label\">y</span></div>\n      <div class=\"decomp-part dp-v\"><span class=\"part-label\">y</span></div>\n      <div class=\"decomp-part dp-v\"><span class=\"part-label\">y</span></div>\n      <div class=\"decomp-part dp-z\"><span class=\"part-label\">z &nbsp;(i=3)</span></div>\n    </div>\n  </div>\n\n  <div class=\"callout key\">\n    <strong>Dire√ß√£o da implica√ß√£o:</strong> o Lema diz que regularidade ‚üπ propriedade de bombeamento. Para provar que L n√£o √© regular, provamos que L viola a propriedade de bombeamento ‚Äî o que √© a contrapositiva: ¬¨(propriedade) ‚üπ ¬¨(regularidade).\n  </div>\n</section>\n\n<section id=\"prova\">\n  <h2><span class=\"num\">2</span> Estrutura de uma prova de n√£o-regularidade</h2>\n\n  <p>Uma prova de n√£o-regularidade via Lema do Bombeamento segue sempre o mesmo esquema de <strong>jogo entre dois advers√°rios</strong>: voc√™ precisa contradizer o lema independentemente das escolhas do advers√°rio.</p>\n\n  <div class=\"card\">\n    <strong>Estrutura padr√£o (prova por contradi√ß√£o):</strong><br><br>\n    <strong>Suponha</strong> que L √© regular. Ent√£o existe p (o advers√°rio escolhe p).<br><br>\n    <strong>Escolha</strong> uma string w ‚àà L com |w| ‚â• p (voc√™ escolhe w em fun√ß√£o de p).<br><br>\n    <strong>Para toda decomposi√ß√£o</strong> w = xyz satisfazendo (1) e (2), o lema garante que xy¬≤z ‚àà L.<br>\n    O advers√°rio escolhe a decomposi√ß√£o.<br><br>\n    <strong>Mostre</strong> que algum xy<sup>i</sup>z ‚àâ L ‚Äî contradi√ß√£o com (3).<br>\n    Voc√™ escolhe i.<br><br>\n    <strong>Conclus√£o:</strong> L n√£o √© regular. ‚àé\n  </div>\n\n  <div class=\"callout tip\">\n    <strong>Dica de escolha de w:</strong> escolha w de forma que qualquer poss√≠vel decomposi√ß√£o xyz (satisfazendo as condi√ß√µes) force a contradi√ß√£o. Strings do tipo <code>a‚Åøb‚Åø</code>, <code>a·µñ</code>, ou <code>a·µñb·µñ</code> s√£o cl√°ssicas porque a condi√ß√£o |xy| ‚â§ p restringe y a estar dentro de um bloco homog√™neo.\n  </div>\n\n  <h3>Exemplo 1 ‚Äî L = {a‚Åøb‚Åø | n ‚â• 0} n√£o √© regular</h3>\n  <div class=\"card\">\n    <strong>Suponha</strong> L regular, p o comprimento de bombeamento.<br>\n    <strong>Escolha</strong> w = a·µñb·µñ. Claramente w ‚àà L e |w| = 2p ‚â• p.<br>\n    <strong>Decomposi√ß√£o:</strong> w = xyz. Por (2), |xy| ‚â§ p, ent√£o x e y est√£o dentro do bloco de a's.<br>\n    Portanto: x = aÀ¢, y = a·µó (t ‚â• 1), z = a·µñ‚ÅªÀ¢‚Åª·µób·µñ.<br>\n    <strong>Bombeie com i=0:</strong> xy‚Å∞z = aÀ¢a·µñ‚ÅªÀ¢‚Åª·µób·µñ = a·µñ‚Åª·µób·µñ.<br>\n    Como t ‚â• 1, temos p-t &lt; p, logo xy‚Å∞z tem mais b's que a's ‚Üí xy‚Å∞z ‚àâ L. Contradi√ß√£o. ‚àé\n  </div>\n\n  <h3>Exemplo 2 ‚Äî L = {0‚Åø | n √© quadrado perfeito} n√£o √© regular</h3>\n  <div class=\"card\">\n    <strong>Suponha</strong> L regular, p o comprimento de bombeamento.<br>\n    <strong>Escolha</strong> w = 0^(p¬≤). Temos |w| = p¬≤ ‚â• p e p¬≤ √© quadrado perfeito, ent√£o w ‚àà L.<br>\n    <strong>Decomposi√ß√£o:</strong> w = xyz com y = 0·µó, t ‚â• 1, |xy| ‚â§ p.<br>\n    <strong>Bombeie com i=2:</strong> xy¬≤z = 0^(p¬≤+t).<br>\n    Precisamos verificar: √© p¬≤+t quadrado perfeito? p¬≤ &lt; p¬≤+t ‚â§ p¬≤+p &lt; (p+1)¬≤.<br>\n    Como (p+1)¬≤ = p¬≤+2p+1 &gt; p¬≤+p ‚â• p¬≤+t, temos p¬≤ &lt; p¬≤+t &lt; (p+1)¬≤.<br>\n    N√£o h√° quadrado perfeito entre p¬≤ e (p+1)¬≤ exclusivos, ent√£o xy¬≤z ‚àâ L. Contradi√ß√£o. ‚àé\n  </div>\n\n  <h3>Exemplo 3 ‚Äî L = {ww | w ‚àà {a,b}*} n√£o √© regular</h3>\n  <div class=\"card\">\n    <strong>Escolha</strong> w = a·µñba·µñb ‚àà L (com w = a·µñb repetido).<br>\n    <strong>Decomposi√ß√£o:</strong> |xy| ‚â§ p, ent√£o y = a·µó dentro do primeiro bloco de a's.<br>\n    <strong>Bombeie com i=0:</strong> xy‚Å∞z = a·µñ‚Åª·µóba·µñb. Para ser da forma ss, a string deve ter comprimento par e a segunda metade igual √† primeira. Mas 2p+2-t ‚â† 2(p+1-t) quando t √© √≠mpar, e a estrutura √© assim√©trica. Nenhuma decomposi√ß√£o v√°lida salva a string. ‚àé\n  </div>\n</section>\n\n<section id=\"simulador\">\n  <h2><span class=\"num\">3</span> Simulador do Lema do Bombeamento</h2>\n\n  <div id=\"pump-sim\">\n    <div class=\"pump-header\">\n      <h3>üî¨ Simulador ‚Äî Lema do Bombeamento</h3>\n      <span class=\"pump-badge\">Visualiza xyz e bombeamento</span>\n    </div>\n    <div class=\"pump-body\">\n\n      <div class=\"pump-presets\">\n        <button class=\"pump-preset active\">a‚Åøb‚Åø (n√£o regular)</button>\n        <button class=\"pump-preset\">a*b* (regular)</button>\n        <button class=\"pump-preset\">0‚Åø¬≤ (n√£o regular)</button>\n        <button class=\"pump-preset\">n¬∫ par de a's (regular)</button>\n      </div>\n\n      <div id=\"pump-desc\" class=\"callout tip\" style=\"font-size:0.88rem; margin-bottom:0.8rem;\">Selecione uma linguagem.</div>\n\n      <div class=\"pump-controls\">\n        <label style=\"font-size:0.85rem; font-weight:600; color:var(--primary);\">p =</label>\n        <input type=\"number\" id=\"pump-p\" class=\"pump-input\" value=\"3\" min=\"1\" max=\"10\" style=\"width:60px;\">\n        <label style=\"font-size:0.85rem; font-weight:600; color:var(--primary);\">i (bombear) =</label>\n        <input type=\"number\" id=\"pump-i\" class=\"pump-input\" value=\"0\" min=\"0\" max=\"5\" style=\"width:60px;\">\n        <button class=\"pump-btn btn-red\">‚ñ∂ Visualizar</button>\n        <button class=\"pump-btn btn-sec\">‚Ü∫</button>\n      </div>\n\n      <div id=\"pump-visual\">\n        <div style=\"font-size:0.78rem; text-transform:uppercase; letter-spacing:1px; color:var(--muted); margin-bottom:0.4rem;\">String original (w)</div>\n        <div id=\"pump-word-display\"></div>\n        <div style=\"font-size:0.78rem; text-transform:uppercase; letter-spacing:1px; color:var(--muted); margin: 0.6rem 0 0.3rem;\">String bombeada (xy<sup id=\"pump-i-label\">i</sup>z)</div>\n        <div id=\"pump-pumped-display\" style=\"display:flex; gap:2px; flex-wrap:wrap; min-height:42px; align-items:center;\"></div>\n      </div>\n\n      <div id=\"pump-log\"><span style=\"color:var(--muted);\">Selecione uma linguagem e clique em Visualizar.</span></div>\n    </div>\n  </div>\n</section>\n\n<section id=\"llc\">\n  <h2><span class=\"num\">4</span> Lema do Bombeamento para LLCs</h2>\n\n  <p>O M√≥dulo 7 apresentou o enunciado. Aqui vemos um exemplo de uso para provar que uma linguagem n√£o √© LLC.</p>\n\n  <div class=\"fbox red\" style=\"font-size:0.92rem;\">\n    <span class=\"flabel\">Lema do Bombeamento ‚Äî LLCs</span>\n    w = uvxyz onde: |vy| ‚â• 1, |vxy| ‚â§ p, ‚àÄi ‚â• 0: uv‚Å±xy‚Å±z ‚àà L\n    <span class=\"fsub\">v e y s√£o bombeadas juntas (sim√©tricas). Isso captura a estrutura de aninhamento das GLCs.</span>\n  </div>\n\n  <h3>Exemplo ‚Äî L = {a‚Åøb‚Åøc‚Åø | n ‚â• 0} n√£o √© LLC</h3>\n  <div class=\"card\">\n    <strong>Suponha</strong> L LLC, p o comprimento de bombeamento.<br>\n    <strong>Escolha</strong> w = a·µñb·µñc·µñ. Temos |w| = 3p ‚â• p e w ‚àà L.<br>\n    <strong>Decomposi√ß√£o</strong> w = uvxyz, |vxy| ‚â§ p, |vy| ‚â• 1.<br><br>\n    Como |vxy| ‚â§ p, o bloco vxy n√£o pode cobrir todos os tr√™s tipos de s√≠mbolos. H√° dois casos:<br><br>\n    <strong>Caso 1:</strong> vxy est√° dentro de a·µñb·µñ (n√£o toca c's).<br>\n    Bombeando i=2: v e y adicionam a's e/ou b's mas n√£o c's ‚Üí mais a's ou b's que c's ‚Üí n√£o pertence a L.<br><br>\n    <strong>Caso 2:</strong> vxy est√° dentro de b·µñc·µñ (n√£o toca a's).<br>\n    Bombeando i=2: mais b's ou c's mas n√£o a's ‚Üí desequil√≠brio ‚Üí n√£o pertence a L.<br><br>\n    Em ambos os casos, contradi√ß√£o. Portanto L n√£o √© LLC. ‚àé\n  </div>\n\n  <h3>Compara√ß√£o dos dois lemas</h3>\n  <table>\n    <tbody><tr><th>Aspecto</th><th>Lema para Regulares</th><th>Lema para LLCs</th></tr>\n    <tr><td>Decomposi√ß√£o</td><td>w = xyz</td><td>w = uvxyz</td></tr>\n    <tr><td>O que √© bombeado</td><td>y (uma parte)</td><td>v e y juntas (sim√©tricas)</td></tr>\n    <tr><td>Restri√ß√£o de tamanho</td><td>|xy| ‚â§ p</td><td>|vxy| ‚â§ p</td></tr>\n    <tr><td>Condi√ß√£o n√£o-trivial</td><td>|y| ‚â• 1</td><td>|vy| ‚â• 1</td></tr>\n    <tr><td>Prova usa</td><td>Princ√≠pio da casa de pombos em estados do AFD</td><td>√Årvore de deriva√ß√£o: n√≥ repetido no caminho mais longo</td></tr>\n  </tbody></table>\n</section>\n\n<section id=\"chomsky\">\n  <h2><span class=\"num\">5</span> A Hierarquia de Chomsky</h2>\n\n  <p>Noam Chomsky (1956) classificou as gram√°ticas formais em quatro tipos, formando uma hierarquia de inclus√£o estrita. Cada tipo corresponde a um modelo computacional e a uma classe de linguagens.</p>\n\n  <canvas id=\"chomsky-canvas\" style=\"height: 320px;\"></canvas>\n\n  <table style=\"margin-top:1rem;\">\n    <tbody><tr><th>Tipo</th><th>Gram√°tica</th><th>Restri√ß√£o nas produ√ß√µes</th><th>Aut√¥mato equivalente</th></tr>\n    <tr><td><strong>Tipo 3</strong></td><td>Regular</td><td>A ‚Üí aB ou A ‚Üí a (linear √† direita)</td><td>AFD / AFN</td></tr>\n    <tr class=\"hl\"><td><strong>Tipo 2</strong></td><td>Livre de contexto</td><td>A ‚Üí Œ± (A √© vari√°vel, Œ± ‚àà (V‚à™Œ£)*)</td><td>PDA (aut√¥mato de pilha)</td></tr>\n    <tr><td><strong>Tipo 1</strong></td><td>Sens√≠vel ao contexto</td><td>Œ±AŒ≤ ‚Üí Œ±Œ≥Œ≤ (n√£o reduz comprimento)</td><td>MT limitada linearmente (LBA)</td></tr>\n    <tr><td><strong>Tipo 0</strong></td><td>Irrestrita</td><td>Qualquer produ√ß√£o Œ± ‚Üí Œ≤</td><td>M√°quina de Turing</td></tr>\n  </tbody></table>\n\n  <h3>Exemplos de linguagens em cada n√≠vel</h3>\n  <div class=\"three-col\">\n    <div class=\"pane\">\n      <h4>Tipo 3 ‚Äî Regulares</h4>\n      <p><code>(ab)*</code></p>\n      <p><code>0*1*</code></p>\n      <p>strings com n√∫mero par de a's</p>\n    </div>\n    <div class=\"pane\">\n      <h4>Tipo 2 ‚Äî LLCs</h4>\n      <p><code>{a‚Åøb‚Åø}</code></p>\n      <p>par√™nteses balanceados</p>\n      <p>linguagens de programa√ß√£o</p>\n    </div>\n    <div class=\"pane\">\n      <h4>Tipo 1 / Tipo 0</h4>\n      <p><code>{a‚Åøb‚Åøc‚Åø}</code> ‚Äî Tipo 1</p>\n      <p><code>{ww}</code> ‚Äî Tipo 1</p>\n      <p>problema da parada ‚Äî Tipo 0, indecid√≠vel</p>\n    </div>\n  </div>\n\n  <div class=\"callout ok\">\n    <strong>Inclus√µes s√£o estritas:</strong> Regular ‚ää LLC ‚ää Sens√≠vel ao Contexto ‚ää Rec. Enumer√°vel. Cada conjunto cont√©m linguagens que n√£o est√£o no conjunto menor. A prova usa os Lemas do Bombeamento (para regulares e LLCs) e resultados de indecidibilidade (para os tipos superiores).\n  </div>\n</section>\n\n<section id=\"mt\">\n  <h2><span class=\"num\">6</span> M√°quinas de Turing</h2>\n\n  <p>Uma <strong>M√°quina de Turing (MT)</strong> √© o modelo computacional mais poderoso na hierarquia. Ela tem acesso de leitura e escrita em uma fita infinita e pode mover a cabe√ßa em ambas as dire√ß√µes ‚Äî ao contr√°rio do AFD (s√≥ leitura, s√≥ avan√ßa) e do PDA (pilha LIFO).</p>\n\n  <div class=\"fbox dark\">\n    <span class=\"flabel\">Defini√ß√£o formal ‚Äî M√°quina de Turing</span>\n    M = (Q, Œ£, Œì, Œ¥, q‚ÇÄ, q_acc, q_rej)\n    <span class=\"fsub\" style=\"text-align:left; display:block; max-width:500px; margin:0.6rem auto 0;\">\n      Q = estados | Œ£ = alfabeto de entrada | Œì ‚äá Œ£‚à™{‚äî} = alfabeto da fita (‚äî = branco)<br>\n      Œ¥: Q √ó Œì ‚Üí Q √ó Œì √ó {L, R} = fun√ß√£o de transi√ß√£o<br>\n      q‚ÇÄ = estado inicial | q_acc = estado de aceita√ß√£o | q_rej = estado de rejei√ß√£o\n    </span>\n  </div>\n\n  <h3>A fita da M√°quina de Turing</h3>\n  <div class=\"card\">\n    <div class=\"tm-tape\">\n      <div class=\"tm-cell blank\">‚äî</div>\n      <div class=\"tm-cell blank\">‚äî</div>\n      <div class=\"tm-cell\">a</div>\n      <div class=\"tm-cell\">a</div>\n      <div class=\"tm-cell head\">b</div>\n      <div class=\"tm-cell\">b</div>\n      <div class=\"tm-cell blank\">‚äî</div>\n      <div class=\"tm-cell blank\">‚äî</div>\n    </div>\n    <p style=\"font-size:0.82rem; color:var(--muted); margin-top:0.5rem; text-align:center;\">Fita com conte√∫do \"aabb\". Cabe√ßa (vermelho) lendo o primeiro 'b'. A fita √© infinita em ambas as dire√ß√µes.</p>\n  </div>\n\n  <h3>Diferen√ßas fundamentais em rela√ß√£o a AFD e PDA</h3>\n  <table>\n    <tbody><tr><th>Aspecto</th><th>AFD</th><th>PDA</th><th>MT</th></tr>\n    <tr><td>Mem√≥ria</td><td>Finita (estados)</td><td>Pilha ilimitada (LIFO)</td><td>Fita ilimitada (acesso livre)</td></tr>\n    <tr><td>Leitura/Escrita</td><td>S√≥ leitura</td><td>L√™ fita, l√™/escreve pilha</td><td>L√™ e escreve na fita</td></tr>\n    <tr><td>Dire√ß√£o</td><td>S√≥ direita</td><td>S√≥ direita (fita)</td><td>Esquerda e direita</td></tr>\n    <tr><td>Rejei√ß√£o</td><td>N√£o chegar a estado final</td><td>Idem</td><td>Estado q_rej ou loop infinito</td></tr>\n    <tr class=\"hl\"><td>Poder</td><td>Menor</td><td>Intermedi√°rio</td><td>M√°ximo (Tese de Church-Turing)</td></tr>\n  </tbody></table>\n\n  <div class=\"callout key\">\n    <strong>Tese de Church-Turing:</strong> toda fun√ß√£o comput√°vel por qualquer modelo razo√°vel de computa√ß√£o √© tamb√©m comput√°vel por uma M√°quina de Turing. Ela n√£o √© um teorema demonstr√°vel matematicamente ‚Äî √© uma tese sobre o que significa \"computa√ß√£o efetiva\". Mas toda tentativa hist√≥rica de formalizar computa√ß√£o resultou em modelos equivalentes √† MT.\n  </div>\n</section>\n\n<section id=\"decidibilidade\">\n  <h2><span class=\"num\">7</span> Decidibilidade e Linguagens Recursivas</h2>\n\n  <p>Nem toda linguagem que uma MT pode reconhecer ela consegue <em>decidir</em>. A diferen√ßa est√° no comportamento quando a resposta √© \"n√£o\":</p>\n\n  <div class=\"split\">\n    <div class=\"pane\">\n      <h4>Linguagem recursivamente enumer√°vel (RE)</h4>\n      <p>Uma MT M <strong>reconhece</strong> L se: para toda w ‚àà L, M aceita w. Para w ‚àâ L, M pode rejeitar <em>ou</em> entrar em loop infinito.</p>\n      <p>Equivale ao Tipo 0 de Chomsky.</p>\n    </div>\n    <div class=\"pane\">\n      <h4>Linguagem recursiva (decid√≠vel)</h4>\n      <p>Uma MT M <strong>decide</strong> L se: para toda w ‚àà L, M aceita. Para toda w ‚àâ L, M rejeita. M <em>sempre para</em>.</p>\n      <p>Subconjunto estrito das linguagens RE.</p>\n    </div>\n  </div>\n\n  <div class=\"fbox dark\" style=\"font-size:0.95rem;\">\n    <span class=\"flabel\">Hierarquia de decidibilidade</span>\n    Regular ‚ää LLC ‚ää Decid√≠vel ‚ää Rec. Enumer√°vel ‚ää Todas as linguagens\n    <span class=\"fsub\">H√° linguagens fora de cada conjunto ‚Äî e h√° linguagens que nenhuma MT consegue sequer reconhecer.</span>\n  </div>\n\n  <h3>Exemplos can√¥nicos</h3>\n  <table>\n    <tbody><tr><th>Linguagem</th><th>Classifica√ß√£o</th><th>Intui√ß√£o</th></tr>\n    <tr><td>L(M) para qualquer AFD M</td><td>Regular</td><td>AFD √© MT muito restrita</td></tr>\n    <tr><td>ACCEPT_AFD = {‚ü®M,w‚ü© | M aceita w}</td><td>Decid√≠vel</td><td>Simule o AFD ‚Äî sempre para</td></tr>\n    <tr><td>ACCEPT_MT = {‚ü®M,w‚ü© | M aceita w}</td><td>RE, mas indecid√≠vel</td><td>Problema da Parada ‚Äî ver pr√≥xima se√ß√£o</td></tr>\n    <tr class=\"hl\"><td>HALT = {‚ü®M,w‚ü© | M para com entrada w}</td><td>Indecid√≠vel</td><td>Teorema de Turing (1936)</td></tr>\n    <tr><td>EQ_MT = {‚ü®M‚ÇÅ,M‚ÇÇ‚ü© | L(M‚ÇÅ)=L(M‚ÇÇ)}</td><td>Nem RE</td><td>Nem MT para sempre reconhece</td></tr>\n  </tbody></table>\n</section>\n\n<section id=\"parada\">\n  <h2><span class=\"num\">8</span> O Problema da Parada</h2>\n\n  <p>O <strong>Problema da Parada</strong> (Halting Problem) √© a prova mais famosa de indecidibilidade. Alan Turing demonstrou em 1936 que n√£o existe nenhum algoritmo que, dado qualquer programa e qualquer entrada, determine se o programa para ou entra em loop infinito.</p>\n\n  <div class=\"fbox dark\">\n    <span class=\"flabel\">Teorema de Turing (1936)</span>\n    HALT = {‚ü®M,w‚ü© | M √© uma MT que para quando recebe w como entrada}<br>n√£o √© decid√≠vel.\n    <span class=\"fsub\">N√£o existe MT H que decide HALT. Para qualquer H, existe (M,w) onde H erra.</span>\n  </div>\n\n  <h3>Prova por diagonaliza√ß√£o (esbo√ßo)</h3>\n  <div class=\"card\">\n    <strong>Suponha por contradi√ß√£o</strong> que existe uma MT H que decide HALT:<br>\n    H(‚ü®M,w‚ü©) = aceita se M para com w; rejeita se M n√£o para com w.<br><br>\n    <strong>Construa</strong> uma MT D que ao receber ‚ü®M‚ü©:<br>\n    1. Executa H(‚ü®M, ‚ü®M‚ü©‚ü©) ‚Äî pergunta se M para quando recebe a pr√≥pria descri√ß√£o<br>\n    2. Se H aceita (M para): D entra em loop infinito<br>\n    3. Se H rejeita (M n√£o para): D para (aceita)<br><br>\n    <strong>Contradi√ß√£o:</strong> o que acontece quando executamos D(‚ü®D‚ü©)?<br>\n    ‚Ä¢ Se D para com ‚ü®D‚ü©: H diria \"aceita\", ent√£o D entraria em loop ‚Üí D n√£o para. Contradi√ß√£o.<br>\n    ‚Ä¢ Se D n√£o para com ‚ü®D‚ü©: H diria \"rejeita\", ent√£o D pararia ‚Üí D para. Contradi√ß√£o.<br><br>\n    Em todo caso, contradi√ß√£o. Logo H n√£o pode existir. ‚àé\n  </div>\n\n  <div class=\"callout warn\">\n    <strong>Impacto pr√°tico:</strong> a indecidibilidade do problema da parada significa que n√£o existe antiv√≠rus perfeito, n√£o existe verificador autom√°tico de termina√ß√£o de programas, e n√£o existe compilador que detecte todos os programas que entram em loop. Esses limites s√£o fundamentais, n√£o apenas limita√ß√µes tecnol√≥gicas.\n  </div>\n\n  <h3>Redu√ß√µes e indecidibilidade</h3>\n  <div class=\"card\">\n    Para provar que outros problemas s√£o indecid√≠veis, usa-se <strong>redu√ß√£o</strong>: mostra-se que se o novo problema fosse decid√≠vel, tamb√©m conseguir√≠amos decidir HALT ‚Äî contradi√ß√£o.<br><br>\n    Exemplos de problemas indecid√≠veis por redu√ß√£o:<br>\n    ‚Ä¢ Verificar se L(M) = ‚àÖ para uma MT M<br>\n    ‚Ä¢ Verificar se L(M‚ÇÅ) = L(M‚ÇÇ) para MTs M‚ÇÅ, M‚ÇÇ<br>\n    ‚Ä¢ Verificar se M aceita pelo menos uma string<br>\n    ‚Ä¢ Verificar se um programa tem um bug espec√≠fico (Rice's Theorem: toda propriedade n√£o-trivial de L(M) √© indecid√≠vel)\n  </div>\n</section>\n\n<section id=\"quiz\">\n  <h2><span class=\"num\">9</span> Exerc√≠cios ‚Äî estilo POSCOMP</h2>\n\n  <div class=\"quiz\">\n    <h3>Quest√£o 1</h3>\n    <p>Para provar que L = {0‚Åø | n ‚â• 1} N√ÉO √© regular pelo Lema do Bombeamento, qual string deve ser escolhida?</p>\n    <div class=\"options\" id=\"q1\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"A\"> A) 0 (comprimento 1)</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"B\"> B) 0·µñ (comprimento exatamente p)</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"C\"> C) 0^(p+1) (comprimento p+1)</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"D\"> D) Esta prova n√£o funciona pois L = {0‚Åø | n ‚â• 1} √â regular</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q1\" data-answer-key=\"D\" data-explanation-id=\"e1\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q1-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Quest√£o 2</h3>\n    <p>No Lema do Bombeamento para linguagens regulares, a condi√ß√£o |xy| ‚â§ p garante que:</p>\n    <div class=\"options\" id=\"q2\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"A\"> A) A string bombeada tem comprimento limitado por p</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"B\"> B) y est√° dentro dos primeiros p s√≠mbolos ‚Äî correspondendo a um estado repetido no caminho inicial do AFD</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"C\"> C) O comprimento de y √© exatamente p</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"D\"> D) z tem comprimento zero</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q2\" data-answer-key=\"B\" data-explanation-id=\"e2\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q2-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Quest√£o 3 ‚Äî Hierarquia de Chomsky</h3>\n    <p>Qual das op√ß√µes apresenta a rela√ß√£o de inclus√£o correta entre as classes de linguagens?</p>\n    <div class=\"options\" id=\"q3\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"A\"> A) LLC ‚ää Regular ‚ää Decid√≠vel</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"B\"> B) Regular ‚ää LLC ‚ää Decid√≠vel ‚ää RE</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"C\"> C) Regular = LLC ‚ää Decid√≠vel</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"D\"> D) Decid√≠vel ‚ää LLC ‚ää Regular ‚ää RE</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q3\" data-answer-key=\"B\" data-explanation-id=\"e3\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q3-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Quest√£o 4 ‚Äî Problema da Parada</h3>\n    <p>O Problema da Parada (HALT) √©:</p>\n    <div class=\"options\" id=\"q4\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"A\"> A) Decid√≠vel ‚Äî basta simular a MT por p passos</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"B\"> B) Recursivamente enumer√°vel mas n√£o decid√≠vel ‚Äî uma MT pode reconhec√™-lo mas n√£o decidir</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"C\"> C) Nem recursivamente enumer√°vel</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"D\"> D) Decid√≠vel apenas para MTs determin√≠sticas</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q4\" data-answer-key=\"B\" data-explanation-id=\"e4\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q4-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Quest√£o 5 ‚Äî POSCOMP n√≠vel dif√≠cil</h3>\n    <p>Considere a afirma√ß√£o: \"Se L √© uma linguagem recursivamente enumer√°vel e LÃÑ (complemento de L) tamb√©m √© recursivamente enumer√°vel, ent√£o L √© decid√≠vel.\" Essa afirma√ß√£o √©:</p>\n    <div class=\"options\" id=\"q5\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"A\"> A) Falsa ‚Äî existem linguagens RE cujo complemento tamb√©m √© RE mas que n√£o s√£o decid√≠veis</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"B\"> B) Verdadeira ‚Äî rode ambas as MTs em paralelo; a primeira que parar d√° a resposta</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"C\"> C) Falsa ‚Äî linguagens RE nunca s√£o decid√≠veis por defini√ß√£o</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"D\"> D) Verdadeira apenas se o alfabeto for {0,1}</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q5\" data-answer-key=\"B\" data-explanation-id=\"e5\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q5-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Quest√£o 6 ‚Äî Revis√£o geral do curr√≠culo</h3>\n    <p>Qual dos problemas abaixo √© DECID√çVEL?</p>\n    <div class=\"options\" id=\"q6\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q6\" value=\"A\"> A) Dado uma MT M e uma string w, determinar se M aceita w</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q6\" value=\"B\"> B) Dado um AFD M e uma string w, determinar se M aceita w</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q6\" value=\"C\"> C) Dado duas MTs M‚ÇÅ e M‚ÇÇ, determinar se L(M‚ÇÅ) = L(M‚ÇÇ)</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q6\" value=\"D\"> D) Dado uma MT M, determinar se L(M) = ‚àÖ</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q6\" data-answer-key=\"B\" data-explanation-id=\"e6\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q6-res\"></div>\n  </div>\n</section>\n\n<section id=\"resumo\">\n  <h2><span class=\"num\">10</span> Resumo ‚Äî M√≥dulo 8 e Curr√≠culo Completo</h2>\n\n  <div class=\"final-summary\">\n    <h3>üéì Voc√™ completou os 8 m√≥dulos do curr√≠culo de Aut√¥matos</h3>\n\n    <div class=\"sum-section\">\n      <h4>M√≥dulo 8 ‚Äî Lema do Bombeamento e Computabilidade</h4>\n      <div class=\"sum-row\">Lema do Bombeamento (regulares): w = xyz, |y| ‚â• 1, |xy| ‚â§ p, ‚àÄi: xy‚Å±z ‚àà L.</div>\n      <div class=\"sum-row\">Estrutura da prova: suponha, escolha w, mostre contradi√ß√£o para toda decomposi√ß√£o.</div>\n      <div class=\"sum-row\">Lema do Bombeamento (LLCs): w = uvxyz ‚Äî v e y bombeadas juntas e sim√©tricas.</div>\n      <div class=\"sum-row\">Hierarquia de Chomsky: Tipo 3 (AFD) ‚ää Tipo 2 (PDA) ‚ää Tipo 1 (LBA) ‚ää Tipo 0 (MT).</div>\n      <div class=\"sum-row\">MT: l√™/escreve fita infinita, move em ambas as dire√ß√µes ‚Äî modelo computacional m√°ximo.</div>\n      <div class=\"sum-row\">Decid√≠vel vs RE: MT sempre para (decid√≠vel) vs MT pode loopar (RE).</div>\n      <div class=\"sum-row\">Problema da Parada: indecid√≠vel ‚Äî prova por diagonaliza√ß√£o (Turing, 1936).</div>\n    </div>\n\n    <div class=\"sum-section\">\n      <h4>Revis√£o dos 8 m√≥dulos</h4>\n      <div class=\"sum-row\">M√≥dulo 1: Linguagens formais, alfabetos, strings, opera√ß√µes e hierarquia.</div>\n      <div class=\"sum-row\">M√≥dulo 2: AFD ‚Äî defini√ß√£o, computa√ß√£o, DFA m√≠nimo e linguagens regulares.</div>\n      <div class=\"sum-row\">M√≥dulo 3: AFN ‚Äî n√£o-determinismo, Œµ-transi√ß√µes, constru√ß√£o de subconjuntos.</div>\n      <div class=\"sum-row\">M√≥dulo 4: Opera√ß√µes sobre linguagens regulares e propriedades de fechamento.</div>\n      <div class=\"sum-row\">M√≥dulo 5: Minimiza√ß√£o de AFD ‚Äî estados distingu√≠veis, table-filling, Myhill-Nerode.</div>\n      <div class=\"sum-row\">M√≥dulo 6: Express√µes Regulares ‚Äî sintaxe, sem√¢ntica, Thompson, tri√¢ngulo AFD‚ÜîAFN‚ÜîER.</div>\n      <div class=\"sum-row\">M√≥dulo 7: GLC e PDA ‚Äî gram√°ticas, deriva√ß√µes, √°rvores, ambiguidade, equival√™ncia GLC‚â°PDA.</div>\n      <div class=\"sum-row\">M√≥dulo 8: Bombeamento, Hierarquia de Chomsky, MT, decidibilidade, problema da parada.</div>\n    </div>\n\n    <div class=\"congrats\">\n      <h3>üèÜ Curr√≠culo conclu√≠do!</h3>\n      <p>Voc√™ cobriu todos os t√≥picos de Teoria da Computa√ß√£o presentes nas provas POSCOMP. Bons estudos e boa prova.</p>\n    </div>\n  </div>\n</section>"
}
