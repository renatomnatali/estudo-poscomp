{
  "header": {
    "badge": "Módulo 7 de 9",
    "title": "GLC e Autômatos de Pilha",
    "subtitle": "O segundo nível da Hierarquia de Chomsky — linguagens que autômatos finitos não conseguem reconhecer, mas gramáticas livres de contexto e pilhas conseguem.",
    "meta": [
      "~65 min",
      "Nível: Intermediário-Avançado",
      "Simulador PDA + Derivação visual interativa"
    ],
    "progressLabel": "Módulo 7 de 9 — GLC e PDA"
  },
  "navLinks": [
    {
      "id": "motivacao",
      "label": "Motivação"
    },
    {
      "id": "glc",
      "label": "GLC"
    },
    {
      "id": "derivacao",
      "label": "Derivação"
    },
    {
      "id": "arvore",
      "label": "Árvore"
    },
    {
      "id": "ambiguidade",
      "label": "Ambiguidade"
    },
    {
      "id": "pda",
      "label": "PDA"
    },
    {
      "id": "simulador",
      "label": "Simulador"
    },
    {
      "id": "equivalencia",
      "label": "Equiv."
    },
    {
      "id": "propriedades",
      "label": "Propriedades"
    },
    {
      "id": "quiz",
      "label": "Exercícios"
    }
  ],
  "html": "<section id=\"motivacao\">\n  <h2><span class=\"num\">1</span> O que os autômatos finitos não conseguem?</h2>\n\n  <p>Os módulos anteriores mostraram que AFDs, AFNs e expressões regulares têm o mesmo poder: as <strong>linguagens regulares</strong>. Mas há linguagens simples que escapam completamente desse modelo.</p>\n\n  <div class=\"callout key\">\n    <strong>O problema do contador:</strong> a linguagem L = {aⁿbⁿ | n ≥ 0} — strings com n letras 'a' seguidas de n letras 'b' — exige que a máquina \"lembre\" quantos a's leu para verificar que há o mesmo número de b's. Um AFD tem memória finita (apenas seu estado atual) e não pode fazer isso para n arbitrário.\n  </div>\n\n  <p>Para reconhecer essas linguagens, precisamos de um modelo com <strong>memória ilimitada de acesso restrito</strong>: a <em>pilha</em> (stack). O modelo resultante é o <strong>Autômato de Pilha</strong> (PDA — Pushdown Automaton), e a linguagem para especificá-los é a <strong>Gramática Livre de Contexto</strong> (GLC).</p>\n\n  <div class=\"split\">\n    <div class=\"pane\">\n      <h4>Linguagens regulares (Módulos 2–6)</h4>\n      <p>AFD / AFN / ER</p>\n      <p>✓ <code>a*b*</code>, strings com número par de a's</p>\n      <p>✗ <code>aⁿbⁿ</code>, palíndromos, parênteses balanceados</p>\n    </div>\n    <div class=\"pane\">\n      <h4>Linguagens livres de contexto (este módulo)</h4>\n      <p>GLC / PDA</p>\n      <p>✓ <code>aⁿbⁿ</code>, parênteses balanceados, gramáticas de linguagens de programação</p>\n      <p>✗ <code>aⁿbⁿcⁿ</code>, <code>ww</code> (repetição)</p>\n    </div>\n  </div>\n</section>\n\n<section id=\"glc\">\n  <h2><span class=\"num\">2</span> Gramáticas Livres de Contexto</h2>\n\n  <p>Uma <strong>GLC</strong> é um conjunto de regras de substituição (produções) que descrevem como gerar as strings de uma linguagem. O nome \"livre de contexto\" significa que uma variável pode ser substituída independentemente do contexto onde aparece.</p>\n\n  <div class=\"fbox sky\">\n    <span class=\"flabel\">Definição formal de GLC</span>\n    G = (V, Σ, R, S)\n    <span class=\"fsub\" style=\"text-align:left; display:block; max-width:440px; margin:0.6rem auto 0;\">\n      V = conjunto de variáveis (não-terminais)<br>\n      Σ = alfabeto de terminais (V ∩ Σ = ∅)<br>\n      R ⊆ V × (V ∪ Σ)* = conjunto de produções/regras<br>\n      S ∈ V = variável inicial (símbolo de início)\n    </span>\n  </div>\n\n  <h3>Exemplo 1 — Parênteses balanceados</h3>\n  <div class=\"grammar\">\n    <span class=\"nt\">S</span> <span class=\"arr\">→</span> <span class=\"t\">(</span><span class=\"nt\">S</span><span class=\"t\">)</span> <span class=\"bar\">|</span> <span class=\"nt\">SS</span> <span class=\"bar\">|</span> <span class=\"eps\">ε</span>\n    <span class=\"comment\">// S pode ser vazio, par de parênteses envolvendo S, ou concatenação de duas sequências</span>\n  </div>\n  <p>Gera: ε, (), (()), ()(), (()()) — qualquer sequência de parênteses balanceados.</p>\n\n  <h3>Exemplo 2 — L = {aⁿbⁿ | n ≥ 0}</h3>\n  <div class=\"grammar\">\n    <span class=\"nt\">S</span> <span class=\"arr\">→</span> <span class=\"t\">a</span><span class=\"nt\">S</span><span class=\"t\">b</span> <span class=\"bar\">|</span> <span class=\"eps\">ε</span>\n    <span class=\"comment\">// Ou gera \"a ... b\" envolvendo uma recursão, ou termina com ε</span>\n  </div>\n  <p>Gera: ε, ab, aabb, aaabbb — sempre igual número de a's e b's.</p>\n\n  <h3>Exemplo 3 — Expressões aritméticas</h3>\n  <div class=\"grammar\">\n    <span class=\"nt\">E</span> <span class=\"arr\">→</span> <span class=\"nt\">E</span> <span class=\"t\">+</span> <span class=\"nt\">T</span> <span class=\"bar\">|</span> <span class=\"nt\">T</span><br>\n    <span class=\"nt\">T</span> <span class=\"arr\">→</span> <span class=\"nt\">T</span> <span class=\"t\">×</span> <span class=\"nt\">F</span> <span class=\"bar\">|</span> <span class=\"nt\">F</span><br>\n    <span class=\"nt\">F</span> <span class=\"arr\">→</span> <span class=\"t\">(</span><span class=\"nt\">E</span><span class=\"t\">)</span> <span class=\"bar\">|</span> <span class=\"t\">id</span>\n    <span class=\"comment\">// Encode precedência: × tem maior prioridade que +</span>\n  </div>\n  <p>Esta gramática descreve expressões como <code>id + id × id</code> respeitando a precedência padrão de operadores — a base de qualquer compilador.</p>\n\n  <h3>Terminologia</h3>\n  <table>\n    <tbody><tr><th>Termo</th><th>Definição</th><th>Exemplo (G₂ acima)</th></tr>\n    <tr><td>Variável / Não-terminal</td><td>Símbolo que pode ser expandido por produções</td><td>S</td></tr>\n    <tr><td>Terminal</td><td>Símbolo do alfabeto — aparece na string final</td><td>a, b</td></tr>\n    <tr><td>Produção / Regra</td><td>Par (V, w) escrito como V → w</td><td>S → aSb | ε</td></tr>\n    <tr><td>Forma sentencial</td><td>Sequência de variáveis e terminais alcançável a partir de S</td><td>aSb, aaSbb, ab</td></tr>\n    <tr><td>Sentença</td><td>Forma sentencial sem variáveis (apenas terminais)</td><td>ab, aabb</td></tr>\n    <tr class=\"hl\"><td>Linguagem da gramática</td><td>L(G) = conjunto de todas as sentenças</td><td>{aⁿbⁿ | n ≥ 0}</td></tr>\n  </tbody></table>\n</section>\n\n<section id=\"derivacao\">\n  <h2><span class=\"num\">3</span> Derivação — como a gramática gera strings</h2>\n\n  <p>Uma <strong>derivação</strong> é uma sequência de substituições, começando em S e aplicando produções até obter uma sentença (sem variáveis).</p>\n\n  <div class=\"fbox sky\" style=\"font-size:0.95rem;\">\n    <span class=\"flabel\">Notação</span>\n    α <strong>⇒</strong> β &nbsp;(\"α deriva β em um passo\") &nbsp;|&nbsp; α <strong>⇒*</strong> β (\"deriva em zero ou mais passos\")\n    <span class=\"fsub\">w ∈ L(G) ⟺ S ⇒* w</span>\n  </div>\n\n  <h3>Exemplo — derivação de \"aabb\" na gramática S → aSb | ε</h3>\n\n  <div class=\"deriv\">\n    <div class=\"deriv-step\">\n      <span class=\"rule\">início</span>\n      <span class=\"form\"><span class=\"expand\">S</span></span>\n    </div>\n    <div class=\"darrow\">⇒ (aplica S → aSb)</div>\n    <div class=\"deriv-step\">\n      <span class=\"rule\">S → aSb</span>\n      <span class=\"form\">a<span class=\"expand\">S</span>b</span>\n    </div>\n    <div class=\"darrow\">⇒ (aplica S → aSb)</div>\n    <div class=\"deriv-step\">\n      <span class=\"rule\">S → aSb</span>\n      <span class=\"form\">aa<span class=\"expand\">S</span>bb</span>\n    </div>\n    <div class=\"darrow\">⇒ (aplica S → ε)</div>\n    <div class=\"deriv-step\">\n      <span class=\"rule\">S → ε</span>\n      <span class=\"form\">aabb &nbsp;<span style=\"color:var(--green); font-size:0.85rem;\">✓ sentença</span></span>\n    </div>\n  </div>\n\n  <h3>Derivações mais à esquerda e mais à direita</h3>\n  <div class=\"split\">\n    <div class=\"pane\">\n      <h4>Derivação mais à esquerda (leftmost)</h4>\n      <p>Sempre expande a variável mais à esquerda da forma sentencial. É o modo padrão para parsers descendentes (top-down).</p>\n    </div>\n    <div class=\"pane\">\n      <h4>Derivação mais à direita (rightmost)</h4>\n      <p>Sempre expande a variável mais à direita. É o modo usado por parsers LR (bottom-up), que são mais poderosos na prática.</p>\n    </div>\n  </div>\n\n  <div class=\"callout tip\">\n    <strong>Ponto POSCOMP:</strong> para gramáticas não-ambíguas, toda string tem exatamente uma derivação mais à esquerda e uma mais à direita. As duas são estruturalmente equivalentes mas expressas em ordens diferentes.\n  </div>\n</section>\n\n<section id=\"arvore\">\n  <h2><span class=\"num\">4</span> Árvore de derivação (Parse Tree)</h2>\n\n  <p>A <strong>árvore de derivação</strong> (ou parse tree) representa graficamente a estrutura de uma derivação. Ela captura qual produção foi aplicada em cada passo sem impor uma ordem (mais à esquerda ou direita).</p>\n\n  <div class=\"card\">\n    <strong>Propriedades da árvore de derivação:</strong><br>\n    • Raiz = símbolo inicial S<br>\n    • Nós internos = variáveis (não-terminais)<br>\n    • Folhas = terminais ou ε (da esquerda para a direita, formam a sentença)<br>\n    • Filhos de um nó V correspondem ao lado direito de uma produção V → w₁w₂…wₖ\n  </div>\n\n  <h3>Árvore de derivação de \"aabb\" — S → aSb | ε</h3>\n  <canvas id=\"tree-aabb\" class=\"tree-canvas\" style=\"height:200px;\"></canvas>\n\n  <h3>Árvore de derivação de \"id + id × id\" — gramática aritmética</h3>\n  <canvas id=\"tree-arith\" class=\"tree-canvas\" style=\"height:220px;\"></canvas>\n  <p style=\"font-size:0.82rem; color:var(--muted); text-align:center;\">Note que × fica mais fundo na árvore que +, codificando a maior precedência da multiplicação.</p>\n</section>\n\n<section id=\"ambiguidade\">\n  <h2><span class=\"num\">5</span> Ambiguidade</h2>\n\n  <p>Uma gramática é <strong>ambígua</strong> se existe alguma string com duas ou mais árvores de derivação distintas (equivalentemente, duas derivações mais à esquerda distintas).</p>\n\n  <div class=\"fbox sky\" style=\"font-size:0.95rem;\">\n    <span class=\"flabel\">Definição</span>\n    G é ambígua ⟺ ∃w ∈ L(G) com duas árvores de derivação distintas\n  </div>\n\n  <h3>Exemplo — gramática ambígua para expressões</h3>\n  <div class=\"grammar\">\n    <span class=\"nt\">E</span> <span class=\"arr\">→</span> <span class=\"nt\">E</span> <span class=\"t\">+</span> <span class=\"nt\">E</span> <span class=\"bar\">|</span> <span class=\"nt\">E</span> <span class=\"t\">×</span> <span class=\"nt\">E</span> <span class=\"bar\">|</span> <span class=\"t\">id</span>\n    <span class=\"comment\">// Sem estratificação — ambígua!</span>\n  </div>\n  <p>A string <code>id + id × id</code> tem <strong>duas</strong> árvores de derivação: uma que agrupa <code>(id + id) × id</code> e outra que agrupa <code>id + (id × id)</code>. O parser não sabe qual usar.</p>\n\n  <canvas id=\"tree-ambig\" class=\"tree-canvas\" style=\"height:230px;\"></canvas>\n  <p style=\"font-size:0.82rem; color:var(--muted); text-align:center;\">Duas árvores distintas para \"id + id × id\" na gramática E → E+E | E×E | id.</p>\n\n  <h3>Estratégias para eliminar ambiguidade</h3>\n  <div class=\"split\">\n    <div class=\"pane\">\n      <h4>Estratificação (layering)</h4>\n      <p>Cria múltiplos níveis de variáveis (E, T, F) onde cada nível codifica uma precedência. É a técnica usada na gramática aritmética completa.</p>\n    </div>\n    <div class=\"pane\">\n      <h4>Linguagem inerentemente ambígua</h4>\n      <p>Algumas linguagens são <em>inerentemente ambíguas</em>: toda GLC que as descreve é ambígua. Exemplo: {aⁿbᵐcᵐ | n ≥ 1} ∪ {aⁿbⁿcᵐ | m ≥ 1}.</p>\n    </div>\n  </div>\n\n  <div class=\"callout warn\">\n    <strong>Ambiguidade vs. não-determinismo:</strong> gramáticas ambíguas não são \"erradas\" matematicamente — ainda geram a mesma linguagem. O problema é para compiladores: sem uma única árvore de derivação, o significado do programa seria indefinido. Por isso, gramáticas de linguagens de programação devem ser não-ambíguas.\n  </div>\n</section>\n\n<section id=\"pda\">\n  <h2><span class=\"num\">6</span> Autômatos de Pilha (PDA)</h2>\n\n  <p>Um <strong>PDA</strong> é um AFN acrescido de uma <em>pilha</em> (stack) de capacidade ilimitada. A pilha é o mecanismo que permite contar e lembrar informação arbitrária — desde que o acesso seja LIFO (Last In, First Out).</p>\n\n  <div class=\"fbox sky\">\n    <span class=\"flabel\">Definição formal de PDA</span>\n    P = (Q, Σ, Γ, δ, q₀, Z₀, F)\n    <span class=\"fsub\" style=\"text-align:left; display:block; max-width:480px; margin:0.6rem auto 0;\">\n      Q = estados | Σ = alfabeto de entrada | Γ = alfabeto da pilha<br>\n      δ: Q × (Σ∪{ε}) × Γ → 2^(Q×Γ*) = função de transição<br>\n      q₀ ∈ Q = estado inicial | Z₀ ∈ Γ = símbolo inicial da pilha<br>\n      F ⊆ Q = estados de aceitação\n    </span>\n  </div>\n\n  <h3>A transição do PDA</h3>\n  <div class=\"card\">\n    <code>δ(q, a, Z) = {(p, γ), ...}</code><br><br>\n    <strong>Leitura:</strong> no estado q, ao ler símbolo a da entrada (ou ε) e tendo Z no topo da pilha:<br>\n    → vá para o estado p<br>\n    → substitua Z no topo por γ (string de símbolos da pilha, possivelmente ε = pop)<br><br>\n    <strong>Casos especiais:</strong><br>\n    • γ = ε → pop (remove Z da pilha)<br>\n    • γ = Z → push nada (mantém Z — equivalente a ignorar a pilha)<br>\n    • γ = AZ → push A acima de Z<br>\n    • a = ε → ε-transição (não consome símbolo)\n  </div>\n\n  <h3>Dois modos de aceitação</h3>\n  <div class=\"split\">\n    <div class=\"pane\">\n      <h4>Aceitação por estado final</h4>\n      <p>Aceita se ao consumir toda a entrada a máquina está em um estado f ∈ F. O conteúdo da pilha é irrelevante. (Mais comum na teoria.)</p>\n    </div>\n    <div class=\"pane\">\n      <h4>Aceitação por pilha vazia</h4>\n      <p>Aceita se ao consumir toda a entrada a pilha está completamente vazia. Não precisa de estados finais. Os dois modos são equivalentes.</p>\n    </div>\n  </div>\n\n  <h3>PDA para aⁿbⁿ</h3>\n  <div class=\"card\">\n    Estados: q₀, q₁, q₂ (final) | Γ = {A, Z₀}<br><br>\n    <strong>Funcionamento:</strong><br>\n    1. Em q₀: ao ler 'a', empilha 'A'. Permanece em q₀.<br>\n    2. Ao ler 'b' (ainda em q₀), vai para q₁ e desempilha 'A'.<br>\n    3. Em q₁: ao ler 'b', desempilha 'A'. Permanece em q₁.<br>\n    4. Ao ver Z₀ (pilha quase vazia) e sem mais entrada, vai para q₂ (final).<br><br>\n    <strong>Transições:</strong><br>\n    δ(q₀, a, Z₀) = {(q₀, AZ₀)} &nbsp; δ(q₀, a, A) = {(q₀, AA)}<br>\n    δ(q₀, b, A) = {(q₁, ε)} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; δ(q₁, b, A) = {(q₁, ε)}<br>\n    δ(q₁, ε, Z₀) = {(q₂, Z₀)}\n  </div>\n</section>\n\n<section id=\"simulador\">\n  <h2><span class=\"num\">7</span> Simulador de PDA</h2>\n\n  <div id=\"pda-sim\">\n    <div class=\"pda-header\">\n      <h3>⚡ Simulador de PDA — Pilha Interativa</h3>\n      <span class=\"pda-badge\">Execução passo a passo</span>\n    </div>\n    <div class=\"pda-body\">\n\n      <div class=\"preset-row\">\n        <button class=\"preset-btn active\">aⁿbⁿ</button>\n        <button class=\"preset-btn\">Parênteses</button>\n        <button class=\"preset-btn\">Palíndromo par</button>\n      </div>\n\n      <div id=\"pda-desc\" class=\"callout tip\" style=\"font-size:0.88rem; margin-bottom:0.8rem;\">\n        <strong>aⁿbⁿ:</strong> empilha 'A' para cada 'a', desempilha um 'A' para cada 'b'. Aceita se a pilha chega a Z₀ exatamente quando a entrada termina.\n      </div>\n\n      <div class=\"sim-grid\">\n        <div class=\"sim-panel\">\n          <div class=\"sim-panel-label\">Fita de entrada</div>\n          <div id=\"pda-tape\" class=\"tape-visual\"></div>\n        </div>\n        <div class=\"sim-panel\">\n          <div class=\"sim-panel-label\">Pilha (topo → base)</div>\n          <div id=\"pda-stack\" class=\"stack-visual\"><div class=\"stack-empty\">Pilha vazia</div></div>\n        </div>\n      </div>\n\n      <div style=\"margin-bottom:0.8rem;\">\n        <span style=\"font-size:0.85rem; color:var(--muted);\">Estado atual: </span>\n        <strong id=\"pda-state\" style=\"color:var(--sky); font-family:monospace;\">—</strong>\n      </div>\n\n      <div class=\"sim-input-row\">\n        <label>String:</label>\n        <input type=\"text\" id=\"pda-str\" placeholder=\"ex: aaabbb\" maxlength=\"20\">\n        <div class=\"sim-controls\">\n          <button class=\"sim-btn btn-sky\">▶ Iniciar</button>\n          <button class=\"sim-btn btn-sec\">⏭ Passo</button>\n          <button class=\"sim-btn btn-green\">⚡ Executar</button>\n          <button class=\"sim-btn btn-sec\">↺</button>\n        </div>\n      </div>\n\n      <div id=\"pda-log\"><span style=\"color:var(--muted);\">Selecione um PDA, digite uma string e clique em Iniciar.</span></div>\n      <div id=\"pda-result\"></div>\n    </div>\n  </div>\n</section>\n\n<section id=\"equivalencia\">\n  <h2><span class=\"num\">8</span> GLC ≡ PDA — Equivalência</h2>\n\n  <div class=\"fbox teal\">\n    <span class=\"flabel\">Teorema fundamental</span>\n    Uma linguagem é livre de contexto ⟺ é reconhecida por algum PDA\n    <span class=\"fsub\">GLC e PDA têm exatamente o mesmo poder expressivo</span>\n  </div>\n\n  <h3>GLC → PDA (construção)</h3>\n  <div class=\"card\">\n    Dado G = (V, Σ, R, S), construa um PDA P de 3 estados {q₀, q_loop, q_acc}:<br><br>\n    1. δ(q₀, ε, Z₀) = {(q_loop, SZ₀)} &nbsp;&nbsp;— empilha o símbolo inicial S<br>\n    2. Para cada produção A → w em R:<br>\n    &nbsp;&nbsp;&nbsp;δ(q_loop, ε, A) = {(q_loop, w)} &nbsp;— expande não-terminais no topo<br>\n    3. Para cada terminal a ∈ Σ:<br>\n    &nbsp;&nbsp;&nbsp;δ(q_loop, a, a) = {(q_loop, ε)} &nbsp;— consome terminais da entrada e pilha<br>\n    4. δ(q_loop, ε, Z₀) = {(q_acc, Z₀)} &nbsp;&nbsp;— aceita quando pilha volta a Z₀<br><br>\n    Este PDA simula uma <em>derivação mais à esquerda</em> da gramática.\n  </div>\n\n  <h3>PDA → GLC (construção)</h3>\n  <div class=\"card\">\n    A conversão inversa é mais complexa. Para cada par de estados (p, q) do PDA, cria-se uma variável [p,q] que representa \"ir de p a q consumindo alguma parte da entrada e esvaziando a pilha de volta ao nível inicial\". As produções são derivadas das transições do PDA. O resultado é uma GLC equivalente.\n  </div>\n\n  <div class=\"callout ok\">\n    <strong>Consequência prática:</strong> compiladores usam esse resultado. A gramática de uma linguagem de programação (GLC) é transformada em um parser (equivalente a um PDA) automaticamente por ferramentas como yacc, bison e ANTLR.\n  </div>\n</section>\n\n<section id=\"propriedades\">\n  <h2><span class=\"num\">9</span> Propriedades das linguagens livres de contexto</h2>\n\n  <h3>Fechamento — comparação com regulares</h3>\n  <table>\n    <tbody><tr><th>Operação</th><th>Regulares</th><th>LLCs</th></tr>\n    <tr><td>União (∪)</td><td class=\"yes\" style=\"color:var(--green);font-weight:700;\">✓ Sim</td><td class=\"yes\" style=\"color:var(--green);font-weight:700;\">✓ Sim</td></tr>\n    <tr><td>Concatenação (∘)</td><td class=\"yes\" style=\"color:var(--green);font-weight:700;\">✓ Sim</td><td class=\"yes\" style=\"color:var(--green);font-weight:700;\">✓ Sim</td></tr>\n    <tr><td>Kleene Star (*)</td><td class=\"yes\" style=\"color:var(--green);font-weight:700;\">✓ Sim</td><td class=\"yes\" style=\"color:var(--green);font-weight:700;\">✓ Sim</td></tr>\n    <tr class=\"hl\"><td>Interseção (∩)</td><td class=\"yes\" style=\"color:var(--green);font-weight:700;\">✓ Sim</td><td style=\"color:var(--red);font-weight:700;\">✗ Não (em geral)</td></tr>\n    <tr class=\"hl\"><td>Complemento (¬)</td><td class=\"yes\" style=\"color:var(--green);font-weight:700;\">✓ Sim</td><td style=\"color:var(--red);font-weight:700;\">✗ Não (em geral)</td></tr>\n    <tr><td>Interseção com regular</td><td>—</td><td class=\"yes\" style=\"color:var(--green);font-weight:700;\">✓ Sim (LLC ∩ Regular = LLC)</td></tr>\n  </tbody></table>\n\n  <div class=\"callout warn\">\n    <strong>Contraexemplo para interseção:</strong> L₁ = {aⁿbⁿcᵐ} e L₂ = {aᵐbⁿcⁿ} são LLCs, mas L₁ ∩ L₂ = {aⁿbⁿcⁿ} não é LLC — é sensível ao contexto. Isso é frequentemente cobrado no POSCOMP.\n  </div>\n\n  <h3>Hierarquia de Chomsky — preview do Módulo 8</h3>\n  <div class=\"card\">\n    <table style=\"font-size:0.88rem;\">\n      <tbody><tr><th>Tipo</th><th>Gramática</th><th>Autômato</th><th>Linguagem</th></tr>\n      <tr><td>Tipo 3</td><td>Regular</td><td>AFD / AFN</td><td>Regular</td></tr>\n      <tr class=\"hl\"><td>Tipo 2</td><td>Livre de contexto</td><td>PDA</td><td>Livre de contexto</td></tr>\n      <tr><td>Tipo 1</td><td>Sensível ao contexto</td><td>Máquina de Turing limitada</td><td>Sensível ao contexto</td></tr>\n      <tr><td>Tipo 0</td><td>Irrestrita</td><td>Máquina de Turing</td><td>Recursivamente enumerável</td></tr>\n    </tbody></table>\n    <p style=\"font-size:0.85rem; color:var(--muted); margin-top:0.5rem;\">Cada tipo é um subconjunto estrito do próximo: Regular ⊊ LLC ⊊ Sensível ⊊ Recursiv. Enumerável.</p>\n  </div>\n\n  <h3>Lema do Bombeamento para LLCs</h3>\n  <div class=\"card\">\n    <strong>Enunciado:</strong> se L é LLC, existe p (comprimento de bombeamento) tal que toda string w ∈ L com |w| ≥ p pode ser escrita como w = uvxyz onde:<br><br>\n    1. |vy| ≥ 1 (pelo menos um de v ou y é não-vazio)<br>\n    2. |vxy| ≤ p<br>\n    3. Para todo i ≥ 0: uvⁱxyⁱz ∈ L<br><br>\n    <strong>Uso:</strong> para provar que L <em>não</em> é LLC, assume-se que L é LLC, escolhe-se uma string longa e mostra-se que nenhuma decomposição satisfaz as condições — contradição.\n  </div>\n</section>\n\n<section id=\"quiz\">\n  <h2><span class=\"num\">10</span> Exercícios — estilo POSCOMP</h2>\n\n  <div class=\"quiz\">\n    <h3>Questão 1</h3>\n    <p>Qual GLC gera a linguagem L = {aⁿb²ⁿ | n ≥ 0} (n letras 'a' seguidas de 2n letras 'b')?</p>\n    <div class=\"options\" id=\"q1\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"A\"> A) S → aSb | ε</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"B\"> B) S → aSbb | ε</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"C\"> C) S → aaSb | ε</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"D\"> D) S → aSb | aSbb | ε</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q1\" data-answer-key=\"B\" data-explanation-id=\"e1\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q1-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Questão 2</h3>\n    <p>Uma gramática G é ambígua se:</p>\n    <div class=\"options\" id=\"q2\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"A\"> A) Tem mais produções do que variáveis</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"B\"> B) Gera a mesma string por dois caminhos com a mesma árvore</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"C\"> C) Existe string com duas árvores de derivação distintas</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"D\"> D) Não é possível convertê-la para um PDA determinístico</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q2\" data-answer-key=\"C\" data-explanation-id=\"e2\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q2-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Questão 3</h3>\n    <p>Na definição de PDA, a função de transição δ tem a assinatura:</p>\n    <div class=\"options\" id=\"q3\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"A\"> A) δ: Q × Σ → Q</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"B\"> B) δ: Q × (Σ∪{ε}) × Γ → 2^(Q×Γ*)</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"C\"> C) δ: Q × Σ × Γ → Q × Γ</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"D\"> D) δ: Q × Σ* × Γ* → Q</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q3\" data-answer-key=\"B\" data-explanation-id=\"e3\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q3-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Questão 4 — POSCOMP nível difícil</h3>\n    <p>Sejam L₁ = {aⁿbⁿ | n ≥ 0} e L₂ = {bⁿcⁿ | n ≥ 0}, ambas LLCs. Qual afirmação é correta sobre L₁ ∩ L₂?</p>\n    <div class=\"options\" id=\"q4\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"A\"> A) L₁ ∩ L₂ = ∅, pois L₁ e L₂ têm alfabetos diferentes</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"B\"> B) L₁ ∩ L₂ é LLC, pois LLCs são fechadas sob interseção</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"C\"> C) L₁ ∩ L₂ = {ε}, pois a única string em ambas é a vazia</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"D\"> D) L₁ ∩ L₂ pode ser provada regular pelo fato de que interseção de duas LLCs com regular gera LLC</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q4\" data-answer-key=\"C\" data-explanation-id=\"e4\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q4-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Questão 5</h3>\n    <p>O Lema do Bombeamento para LLCs decompõe w = uvxyz. A condição |vy| ≥ 1 garante que:</p>\n    <div class=\"options\" id=\"q5\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"A\"> A) A string bombeada uv²xy²z tem comprimento máximo p</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"B\"> B) O bombeamento é não-trivial — pelo menos uma parte v ou y é não-vazia</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"C\"> C) A string x é necessariamente vazia</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"D\"> D) v e y têm o mesmo comprimento</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q5\" data-answer-key=\"B\" data-explanation-id=\"e5\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q5-res\"></div>\n  </div>\n</section>\n\n<section id=\"resumo\">\n  <h2><span class=\"num\">11</span> Resumo do módulo</h2>\n\n  <div class=\"summary\">\n    <h3>O que você agora domina:</h3>\n    <div class=\"row\">GLC = (V, Σ, R, S): variáveis, terminais, produções e símbolo inicial.</div>\n    <div class=\"row\">Derivação ⇒*: aplicar produções até obter uma sentença (só terminais).</div>\n    <div class=\"row\">Árvore de derivação: representa a estrutura hierárquica de uma derivação.</div>\n    <div class=\"row\">Ambiguidade: gramática ambígua ↔ alguma string tem duas árvores distintas.</div>\n    <div class=\"row\">PDA = AFN + pilha. Transição lê entrada, consome topo da pilha e empilha nova string.</div>\n    <div class=\"row\">GLC ≡ PDA: toda LLC é reconhecida por PDA e vice-versa.</div>\n    <div class=\"row\">LLCs: fechadas sob ∪, ∘, *; NÃO sob ∩ e ¬ em geral; mas LLC ∩ Regular = LLC.</div>\n    <div class=\"row\">Hierarquia de Chomsky: Regular ⊊ LLC ⊊ Sensível ⊊ Recursiv. Enumerável.</div>\n  </div>\n\n  <h3>O que vem no próximo (e último) módulo</h3>\n  <div class=\"card\">\n    O Módulo 8 fecha o ciclo com o <strong>Lema do Bombeamento para linguagens regulares</strong> (prova de não-regularidade), uma revisão completa da <strong>Hierarquia de Chomsky</strong> e introdução à teoria da <strong>computabilidade</strong> — Máquinas de Turing, decidibilidade e o problema da parada.\n  </div>\n</section>"
}
