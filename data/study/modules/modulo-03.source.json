{
  "header": {
    "badge": "M√≥dulo 3 de 9",
    "title": "AFN e Œµ-Transi√ß√µes",
    "subtitle": "N√£o-determinismo, caminhos paralelos, fecho epsilon e a prova de que AFN = AFD em poder expressivo.",
    "meta": [
      "~60 min",
      "N√≠vel: Intermedi√°rio",
      "Simulador paralelo + Constru√ß√£o de subconjuntos"
    ],
    "progressLabel": "M√≥dulo 3 de 9 ‚Äî AFN"
  },
  "navLinks": [
    {
      "id": "intuicao",
      "label": "Intui√ß√£o"
    },
    {
      "id": "definicao",
      "label": "Defini√ß√£o"
    },
    {
      "id": "epsilon",
      "label": "Œµ-Transi√ß√µes"
    },
    {
      "id": "execucao",
      "label": "Execu√ß√£o"
    },
    {
      "id": "simulador",
      "label": "Simulador"
    },
    {
      "id": "subconjuntos",
      "label": "Subconjuntos"
    },
    {
      "id": "builder",
      "label": "Constru√ß√£o"
    },
    {
      "id": "equivalencia",
      "label": "Equival√™ncia"
    },
    {
      "id": "quiz",
      "label": "Exerc√≠cios"
    },
    {
      "id": "resumo",
      "label": "Resumo"
    }
  ],
  "html": "<section id=\"intuicao\">\n  <h2><span class=\"num\">1</span> O que muda no AFN?</h2>\n\n  <p>No AFD, cada par (estado, s√≠mbolo) leva a exatamente <strong>um</strong> pr√≥ximo estado. O AFN relaxa essa restri√ß√£o: um par pode levar a <strong>zero, um ou v√°rios</strong> pr√≥ximos estados simultaneamente.</p>\n\n  <p>Isso soa imposs√≠vel de executar numa m√°quina real ‚Äî e de fato √©. Mas como modelo matem√°tico, o AFN √© extremamente √∫til: √© mais f√°cil de projetar, mais compacto de descrever, e ‚Äî como veremos ‚Äî tem exatamente o mesmo poder expressivo que o AFD.</p>\n\n  <div class=\"callout tip\">\n    <strong>A met√°fora do or√°culo:</strong> imagine que, sempre que o AFN encontra m√∫ltiplas op√ß√µes, ele \"adivinhe\" corretamente qual caminho levar√° √† aceita√ß√£o. Uma string √© aceita se <em>existir ao menos um</em> caminho que termina num estado de aceita√ß√£o. Na pr√°tica, simulamos todos os caminhos em paralelo.\n  </div>\n\n  <div class=\"compare\">\n    <div class=\"col dfa\">\n      <h4>üîµ AFD ‚Äî Determin√≠stico</h4>\n      <ul>\n        <li>Œ¥(q, a) = exatamente 1 estado</li>\n        <li>Execu√ß√£o: √∫nico caminho</li>\n        <li>Sem ambiguidade</li>\n        <li>Mais estados (√†s vezes exponencialmente mais)</li>\n        <li>Mais f√°cil de implementar</li>\n      </ul>\n    </div>\n    <div class=\"col nfa\">\n      <h4>üü£ AFN ‚Äî N√£o-Determin√≠stico</h4>\n      <ul>\n        <li>Œ¥(q, a) = conjunto de estados (pode ser ‚àÖ)</li>\n        <li>Execu√ß√£o: m√∫ltiplos caminhos em paralelo</li>\n        <li>Aceita se qualquer caminho aceita</li>\n        <li>Mais compacto ‚Äî menos estados</li>\n        <li>Mais f√°cil de projetar para certas linguagens</li>\n      </ul>\n    </div>\n  </div>\n</section>\n\n<section id=\"definicao\">\n  <h2><span class=\"num\">2</span> Defini√ß√£o formal do AFN</h2>\n\n  <p>Um AFN tamb√©m √© uma 5-tupla. A diferen√ßa cr√≠tica est√° na assinatura de Œ¥:</p>\n\n  <div class=\"split\">\n    <div class=\"pane\">\n      <h4>AFD ‚Äî fun√ß√£o de transi√ß√£o</h4>\n      <div class=\"fbox\" style=\"font-size:1rem; padding:1rem;\">\n        Œ¥<sub>AFD</sub>: Q √ó Œ£ ‚Üí Q\n      </div>\n      <p style=\"font-size:0.88rem;\">Retorna um √∫nico estado.</p>\n    </div>\n    <div class=\"pane\">\n      <h4>AFN ‚Äî fun√ß√£o de transi√ß√£o</h4>\n      <div class=\"fbox purple\" style=\"font-size:1rem; padding:1rem;\">\n        Œ¥<sub>AFN</sub>: Q √ó (Œ£ ‚à™ {Œµ}) ‚Üí 2<sup>Q</sup>\n      </div>\n      <p style=\"font-size:0.88rem;\">Retorna um <em>conjunto</em> de estados ‚Äî possivelmente vazio.</p>\n    </div>\n  </div>\n\n  <div class=\"fbox purple\">\n    <span class=\"flabel\">Defini√ß√£o formal de AFN</span>\n    N = (Q, Œ£, Œ¥, q‚ÇÄ, F)\n    <span class=\"fsub\">Mesmos 5 componentes, mas Œ¥: Q √ó (Œ£ ‚à™ {Œµ}) ‚Üí 2<sup>Q</sup></span>\n  </div>\n\n  <h3>As tr√™s diferen√ßas-chave em rela√ß√£o ao AFD</h3>\n  <table>\n    <tbody><tr><th>Caracter√≠stica</th><th>AFD</th><th>AFN</th></tr>\n    <tr>\n      <td>Tipo de retorno de Œ¥</td>\n      <td>Um estado <code>q ‚àà Q</code></td>\n      <td>Um conjunto <code>S ‚äÜ Q</code> (pode ser ‚àÖ)</td>\n    </tr>\n    <tr>\n      <td>Transi√ß√£o com Œµ</td>\n      <td>N√£o existe</td>\n      <td>Œ¥(q, Œµ) permitido ‚Äî muda estado sem ler s√≠mbolo</td>\n    </tr>\n    <tr class=\"hl\">\n      <td>Crit√©rio de aceita√ß√£o</td>\n      <td>Estado √∫nico ‚àà F ao fim</td>\n      <td>Ao menos um estado ‚àà F entre todos os caminhos paralelos</td>\n    </tr>\n    <tr>\n      <td>Œ¥ precisa ser total?</td>\n      <td>Sim (AFD completo)</td>\n      <td>N√£o ‚Äî Œ¥(q, a) = ‚àÖ √© v√°lido (caminho morre)</td>\n    </tr>\n  </tbody></table>\n\n  <div class=\"callout\">\n    <strong>Por que 2<sup>Q</sup>?</strong> Como vimos no M√≥dulo 1, 2<sup>Q</sup> √© o conjunto de todos os subconjuntos de Q. Se Q tem n estados, h√° 2<sup>n</sup> poss√≠veis conjuntos de retorno. Œ¥ precisa mapear cada par para um desses subconjuntos ‚Äî incluindo o conjunto vazio ‚àÖ (caminho sem sa√≠da).\n  </div>\n</section>\n\n<section id=\"epsilon\">\n  <h2><span class=\"num\">3</span> Œµ-Transi√ß√µes e o Fecho Epsilon</h2>\n\n  <p>Uma <strong>Œµ-transi√ß√£o</strong> (ou transi√ß√£o vazia) permite que o aut√¥mato mude de estado <em>sem consumir nenhum s√≠mbolo da entrada</em>. √â como um \"salto livre\".</p>\n\n  <div class=\"card\">\n    <p>Exemplo: <code>Œ¥(q1, Œµ) = {q2, q3}</code></p>\n    <p>Estando em q1, o AFN pode espontaneamente ir para q2 ou q3 ‚Äî sem ler nada. Isso √© √∫til para \"conectar\" subaut√¥matos.</p>\n  </div>\n\n  <h3>Fecho Epsilon ‚Äî Œµ-closure(q)</h3>\n\n  <p>O <strong>fecho epsilon</strong> de um estado q √© o conjunto de todos os estados alcan√ß√°veis a partir de q usando apenas Œµ-transi√ß√µes (incluindo o pr√≥prio q).</p>\n\n  <div class=\"fbox purple\" style=\"font-size:1rem;\">\n    <span class=\"flabel\">Defini√ß√£o</span>\n    Œµ-closure(q) = { p ‚àà Q | p √© alcan√ß√°vel a partir de q por zero ou mais Œµ-transi√ß√µes }\n    <span class=\"fsub\">Sempre inclui o pr√≥prio q (zero Œµ-transi√ß√µes = permanecer em q)</span>\n  </div>\n\n  <h3>Exemplo de c√°lculo do fecho epsilon</h3>\n  <p>Dado o seguinte conjunto de Œµ-transi√ß√µes:</p>\n  <div class=\"card\">\n    <code>Œ¥(q1, Œµ) = {q2}</code><br>\n    <code>Œ¥(q2, Œµ) = {q3}</code><br>\n    <code>Œ¥(q3, Œµ) = ‚àÖ</code><br>\n    <code>Œ¥(q4, Œµ) = {q1, q5}</code>\n  </div>\n\n  <div class=\"eclosure\">\n    <div class=\"eclosure-row\">\n      <span class=\"badge b-purple\">Œµ-closure(q1)</span>\n      <span class=\"arrow\">‚Üí</span>\n      <span>Come√ßa em q1. Œµ leva a q2. De q2, Œµ leva a q3. De q3, nada mais.</span>\n      <span class=\"badge b-blue\">= {q1, q2, q3}</span>\n    </div>\n    <div class=\"eclosure-row\">\n      <span class=\"badge b-purple\">Œµ-closure(q3)</span>\n      <span class=\"arrow\">‚Üí</span>\n      <span>Come√ßa em q3. N√£o h√° Œµ-transi√ß√µes saindo de q3.</span>\n      <span class=\"badge b-blue\">= {q3}</span>\n    </div>\n    <div class=\"eclosure-row\">\n      <span class=\"badge b-purple\">Œµ-closure(q4)</span>\n      <span class=\"arrow\">‚Üí</span>\n      <span>Come√ßa em q4. Œµ leva a {q1, q5}. De q1, Œµ leva a q2. De q2, Œµ leva a q3. De q5, nada.</span>\n      <span class=\"badge b-blue\">= {q1, q2, q3, q4, q5}</span>\n    </div>\n  </div>\n\n  <div class=\"callout tip\">\n    <strong>Algoritmo de c√°lculo:</strong> √© uma busca em largura/profundidade. Comece com {q}, adicione todos os estados alcan√ß√°veis por Œµ, repita para cada estado rec√©m-adicionado at√© estabilizar. √â sempre finito pois Q √© finito.\n  </div>\n\n  <h3>Fecho epsilon de um conjunto</h3>\n  <p>Extens√£o natural: o fecho epsilon de um <em>conjunto</em> S de estados √© a uni√£o dos fechos individuais:</p>\n  <div class=\"card\">\n    <code>Œµ-closure(S) = ‚ãÉ<sub>q ‚àà S</sub> Œµ-closure(q)</code><br><br>\n    Exemplo: <code>Œµ-closure({q1, q4}) = Œµ-closure(q1) ‚à™ Œµ-closure(q4) = {q1,q2,q3} ‚à™ {q1,q2,q3,q4,q5} = {q1,q2,q3,q4,q5}</code>\n  </div>\n</section>\n\n<section id=\"execucao\">\n  <h2><span class=\"num\">4</span> Como o AFN executa ‚Äî caminhos paralelos</h2>\n\n  <p>A execu√ß√£o de um AFN mant√©m um <strong>conjunto de estados ativos</strong> (n√£o um √∫nico estado como no AFD). A cada passo:</p>\n\n  <div class=\"card\">\n    <strong>Algoritmo de execu√ß√£o do AFN:</strong><br><br>\n    1. Estado inicial: <code>S‚ÇÄ = Œµ-closure({q‚ÇÄ})</code><br>\n    2. Para cada s√≠mbolo <em>a</em> lido:<br>\n    &nbsp;&nbsp;&nbsp;a. Calcule o conjunto de estados alcan√ß√°veis: <code>Move(S, a) = ‚ãÉ<sub>q ‚àà S</sub> Œ¥(q, a)</code><br>\n    &nbsp;&nbsp;&nbsp;b. Aplique o fecho epsilon: <code>S' = Œµ-closure(Move(S, a))</code><br>\n    3. Aceita se <code>S_final ‚à© F ‚â† ‚àÖ</code> (ao menos um estado ativo √© de aceita√ß√£o)\n  </div>\n\n  <h3>Exemplo: AFN que aceita strings terminando em \"ab\"</h3>\n  <p>Sobre Œ£ = {a, b}, com estados Q = {q0, q1, q2}:</p>\n\n  <div class=\"card\">\n    <table>\n      <tbody><tr><th>Œ¥</th><th>a</th><th>b</th><th>Œµ</th></tr>\n      <tr><td>‚Üí q0</td><td>{q0, q1}</td><td>{q0}</td><td>‚àÖ</td></tr>\n      <tr><td>q1</td><td>‚àÖ</td><td>{q2}</td><td>‚àÖ</td></tr>\n      <tr><td>‚òÖ q2</td><td>‚àÖ</td><td>‚àÖ</td><td>‚àÖ</td></tr>\n    </tbody></table>\n    <p style=\"font-size:0.88rem; margin-top:0.5rem; color:var(--muted);\">N√£o-determinismo em q0 com 'a': pode ficar em q0 (continuar buscando) OU ir para q1 (apostando que 'a' √© o in√≠cio de \"ab\").</p>\n  </div>\n\n  <h3>Trace de \"aab\" ‚Äî deve ACEITAR</h3>\n  <div>\n    <div class=\"trace-step\">\n      <span class=\"badge b-blue\">in√≠cio</span>\n      <div>\n        <div>Œµ-closure({q0}) = <span class=\"state-set\" style=\"display:inline-flex;\"><span class=\"state-bubble initial\">q0</span></span></div>\n        <div style=\"font-size:0.85rem; color:var(--muted);\">N√£o h√° Œµ-transi√ß√µes saindo de q0.</div>\n      </div>\n    </div>\n    <div class=\"trace-step\">\n      <span class=\"badge b-purple\">l√™ 'a'</span>\n      <div>\n        <div>Move({q0}, 'a') = Œ¥(q0, 'a') = {q0, q1}</div>\n        <div>Œµ-closure({q0, q1}) = <span class=\"state-set\" style=\"display:inline-flex;\"><span class=\"state-bubble\">q0</span><span class=\"state-bubble\">q1</span></span></div>\n        <div style=\"font-size:0.85rem; color:var(--muted);\">Dois caminhos paralelos: q0 (continua buscando) e q1 (apostou no 'a').</div>\n      </div>\n    </div>\n    <div class=\"trace-step\">\n      <span class=\"badge b-purple\">l√™ 'a'</span>\n      <div>\n        <div>Move({q0,q1}, 'a') = Œ¥(q0,'a') ‚à™ Œ¥(q1,'a') = {q0,q1} ‚à™ ‚àÖ = {q0,q1}</div>\n        <div>Œµ-closure({q0, q1}) = <span class=\"state-set\" style=\"display:inline-flex;\"><span class=\"state-bubble\">q0</span><span class=\"state-bubble\">q1</span></span></div>\n        <div style=\"font-size:0.85rem; color:var(--muted);\">Caminho q1 anterior \"morreu\" (Œ¥(q1,'a')=‚àÖ). Novo q1 aberto pelo q0.</div>\n      </div>\n    </div>\n    <div class=\"trace-step\">\n      <span class=\"badge b-purple\">l√™ 'b'</span>\n      <div>\n        <div>Move({q0,q1}, 'b') = Œ¥(q0,'b') ‚à™ Œ¥(q1,'b') = {q0} ‚à™ {q2} = {q0,q2}</div>\n        <div>Œµ-closure({q0, q2}) = <span class=\"state-set\" style=\"display:inline-flex;\"><span class=\"state-bubble\">q0</span><span class=\"state-bubble final\">q2 ‚òÖ</span></span></div>\n      </div>\n    </div>\n    <div class=\"trace-step\">\n      <span class=\"badge b-green\">ACEITA</span>\n      <div>\n        <div>Conjunto final = {q0, q2}. Como q2 ‚àà F, a interse√ß√£o com F √© n√£o-vazia ‚Üí ACEITA.</div>\n        <div style=\"font-size:0.85rem; color:var(--muted);\">O caminho que \"apostou\" em 'a'‚Üíq1 e leu 'b'‚Üíq2 foi o caminho vencedor.</div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"callout ok\">\n    <strong>Insight fundamental:</strong> o AFN nunca precisa \"escolher\" de forma irrevog√°vel. Ele mant√©m todas as apostas vivas em paralelo. Se qualquer caminho alcan√ßar um estado final ao fim da string, a string √© aceita. Isso √© n√£o-determinismo.\n  </div>\n</section>\n\n<section id=\"simulador\">\n  <h2><span class=\"num\">5</span> Simulador de AFN ‚Äî execu√ß√£o paralela</h2>\n\n  <div id=\"sim-afn\">\n    <div class=\"sim-header\">\n      <h3>‚ö° Simulador AFN ‚Äî Caminhos Paralelos</h3>\n      <span class=\"sbadge\">Conjuntos de estados ativos</span>\n    </div>\n    <div class=\"sim-body\">\n\n      <div class=\"preset-row\">\n        <button class=\"preset-btn active\">Termina em \"ab\"</button>\n        <button class=\"preset-btn\">Cont√©m \"11\"</button>\n        <button class=\"preset-btn\">Demo Œµ-transi√ß√µes</button>\n      </div>\n\n      <div id=\"afn-preset-desc\" class=\"callout tip\" style=\"font-size:0.88rem; margin-bottom:0.8rem;\">\n        <strong>Termina em \"ab\":</strong> aceita strings sobre {a,b} cujo sufixo √© \"ab\". O n√£o-determinismo surge no estado q0: ao ler 'a', o AFN pode apostar que esse 'a' inicia o \"ab\" final, ou continuar no q0 buscando um 'a' posterior.\n      </div>\n\n      <canvas id=\"afn-canvas\"></canvas>\n\n      <div class=\"active-sets\">\n        <div class=\"active-set\">\n          <div class=\"label\">Conjunto de estados ativos</div>\n          <div id=\"afn-active\" class=\"states\"><span style=\"color:var(--muted); font-size:0.85rem;\">‚Äî</span></div>\n        </div>\n        <div class=\"active-set\">\n          <div class=\"label\">Fita de entrada</div>\n          <div id=\"afn-tape\" class=\"sim-tape\"></div>\n        </div>\n      </div>\n\n      <div class=\"sim-input-row\">\n        <label for=\"afn-string\">String:</label>\n        <input type=\"text\" id=\"afn-string\" placeholder=\"ex: aab\" maxlength=\"20\">\n        <div class=\"sim-controls\">\n          <button class=\"sim-btn btn-purple\">‚ñ∂ Iniciar</button>\n          <button class=\"sim-btn btn-secondary\">‚è≠ Passo</button>\n          <button class=\"sim-btn btn-green\">‚ö° Executar</button>\n          <button class=\"sim-btn btn-secondary\">‚Ü∫ Reset</button>\n        </div>\n      </div>\n\n      <div id=\"afn-log\"><span style=\"color:var(--muted);\">Escolha um aut√¥mato, digite uma string e clique em Iniciar.</span></div>\n      <div id=\"afn-result\"></div>\n    </div>\n  </div>\n</section>\n\n<section id=\"subconjuntos\">\n  <h2><span class=\"num\">6</span> Constru√ß√£o de Subconjuntos ‚Äî AFN ‚Üí AFD</h2>\n\n  <p>A prova de que AFN e AFD s√£o equivalentes usa o <strong>algoritmo de constru√ß√£o de subconjuntos</strong> (subset construction). Cada estado do AFD resultante corresponde a um <em>conjunto</em> de estados do AFN.</p>\n\n  <div class=\"callout key\">\n    <strong>Ideia central:</strong> se o AFN mant√©m um conjunto de estados ativos durante a execu√ß√£o, basta transformar esse conjunto em um √∫nico estado do AFD. O AFD constru√≠do simula o AFN exatamente.\n  </div>\n\n  <h3>Algoritmo formal</h3>\n  <div class=\"card\">\n    Dado AFN N = (Q, Œ£, Œ¥<sub>N</sub>, q‚ÇÄ, F<sub>N</sub>), construa AFD M = (Q', Œ£, Œ¥<sub>M</sub>, q'‚ÇÄ, F'):<br><br>\n    <strong>1.</strong> Q' = 2<sup>Q</sup> (subconjuntos de Q ‚Äî potencialmente 2<sup>|Q|</sup> estados)<br>\n    <strong>2.</strong> q'‚ÇÄ = Œµ-closure({q‚ÇÄ})<br>\n    <strong>3.</strong> Œ¥<sub>M</sub>(S, a) = Œµ-closure(‚ãÉ<sub>q ‚àà S</sub> Œ¥<sub>N</sub>(q, a))<br>\n    <strong>4.</strong> F' = { S ‚àà Q' | S ‚à© F<sub>N</sub> ‚â† ‚àÖ }<br>\n    <strong>5.</strong> Explore apenas os estados alcan√ß√°veis (lazy construction) ‚Äî evita explodir com 2<sup>n</sup> estados n√£o-alcan√ßados\n  </div>\n\n  <h3>Exemplo passo a passo</h3>\n  <p>AFN que aceita strings terminando em \"ab\" (Q = {q0, q1, q2}, Œ£ = {a,b}):</p>\n\n  <table class=\"subset-table\">\n    <tbody><tr><th>Estado AFD (subconjunto)</th><th>L√™ 'a'</th><th>L√™ 'b'</th><th>Tipo</th></tr>\n    <tr class=\"subset-initial\">\n      <td><code>{q0}</code> ‚Üê estado inicial do AFD</td>\n      <td><code>{q0, q1}</code></td>\n      <td><code>{q0}</code></td>\n      <td>‚Üí inicial</td>\n    </tr>\n    <tr class=\"subset-new\">\n      <td><code>{q0, q1}</code> ‚Üê novo!</td>\n      <td><code>{q0, q1}</code></td>\n      <td><code>{q0, q2}</code></td>\n      <td>‚Äî</td>\n    </tr>\n    <tr class=\"subset-new subset-final\">\n      <td><code>{q0, q2}</code> ‚Üê novo! cont√©m q2 ‚àà F</td>\n      <td><code>{q0, q1}</code></td>\n      <td><code>{q0}</code></td>\n      <td>‚òÖ final</td>\n    </tr>\n  </tbody></table>\n\n  <div class=\"callout ok\">\n    <strong>Resultado:</strong> o AFN com 3 estados gerou um AFD com apenas 3 estados tamb√©m (os n√£o-alcan√ß√°veis foram ignorados). No pior caso, poderia gerar 2¬≥ = 8 estados, mas na pr√°tica geralmente muito menos.\n  </div>\n\n  <div class=\"callout warn\">\n    <strong>Explos√£o de estados:</strong> existem linguagens para as quais o AFD m√≠nimo √© exponencialmente maior que o AFN. O exemplo cl√°ssico √© a linguagem {w ‚àà {0,1}* | o n-√©simo s√≠mbolo antes do fim √© '1'}, que tem um AFN com n+1 estados e cujo AFD m√≠nimo precisa de 2<sup>n</sup> estados.\n  </div>\n</section>\n\n<section id=\"builder\">\n  <h2><span class=\"num\">7</span> Constru√ß√£o de subconjuntos ‚Äî passo a passo</h2>\n\n  <div class=\"subset-builder\">\n    <div class=\"sb-header\">üîß Constru√ß√£o de subconjuntos ‚Äî AFN \"termina em ab\" ‚Üí AFD</div>\n    <div class=\"sb-body\">\n      <div class=\"sb-controls\">\n        <button class=\"sim-btn btn-purple\">‚è≠ Pr√≥ximo passo</button>\n        <button class=\"sim-btn btn-green\">‚ö° Construir tudo</button>\n        <button class=\"sim-btn btn-secondary\">‚Ü∫ Resetar</button>\n      </div>\n      <div id=\"subset-steps\"></div>\n      <div id=\"subset-table-container\" style=\"margin-top:1rem;\"></div>\n      <div id=\"sb-status\" style=\"font-size:0.85rem; color:var(--muted); margin-top:0.5rem;\"></div>\n    </div>\n  </div>\n</section>\n\n<section id=\"equivalencia\">\n  <h2><span class=\"num\">8</span> Teorema da Equival√™ncia AFN ‚Üî AFD</h2>\n\n  <div class=\"fbox purple\">\n    <span class=\"flabel\">Teorema (Rabin &amp; Scott, 1959)</span>\n    Uma linguagem √© reconhecida por um AFD se e somente se √© reconhecida por um AFN.\n    <span class=\"fsub\">AFD e AFN t√™m exatamente o mesmo poder expressivo ‚Äî ambos reconhecem as linguagens regulares.</span>\n  </div>\n\n  <h3>Por que AFN √© √∫til se AFD faz o mesmo?</h3>\n  <div class=\"split\">\n    <div class=\"pane\">\n      <h4>Design mais simples</h4>\n      <p>Para linguagens como \"strings que cont√™m '101' como subpalavra\", um AFN de 4 estados √© trivial de projetar. O AFD equivalente exige racioc√≠nio mais cuidadoso.</p>\n    </div>\n    <div class=\"pane\">\n      <h4>Base para express√µes regulares</h4>\n      <p>A convers√£o de express√£o regular para aut√¥mato passa inevitavelmente pelo AFN (constru√ß√£o de Thompson). O AFN √© o passo intermedi√°rio natural.</p>\n    </div>\n    <div class=\"pane\">\n      <h4>Prova de propriedades</h4>\n      <p>√â mais f√°cil provar fechamento de linguagens regulares sob uni√£o/concatena√ß√£o usando AFN, e depois converter para AFD.</p>\n    </div>\n    <div class=\"pane\">\n      <h4>An√°lise de complexidade</h4>\n      <p>A diferen√ßa de tamanho entre AFN e AFD m√≠nimo √© um tema rico em complexidade computacional, relevante para POSCOMP n√≠vel dif√≠cil.</p>\n    </div>\n  </div>\n\n  <h3>Roteiro de convers√£o completo</h3>\n  <div class=\"card\">\n    <table>\n      <tbody><tr><th>De</th><th>Para</th><th>M√©todo</th><th>M√≥dulo</th></tr>\n      <tr><td>AFN</td><td>AFD</td><td>Constru√ß√£o de subconjuntos</td><td>Este m√≥dulo</td></tr>\n      <tr><td>AFD</td><td>AFN</td><td>Trivial ‚Äî AFD √© um caso especial de AFN</td><td>Este m√≥dulo</td></tr>\n      <tr><td>ER</td><td>AFN</td><td>Constru√ß√£o de Thompson</td><td>M√≥dulo 6</td></tr>\n      <tr><td>AFD</td><td>ER</td><td>M√©todo de elimina√ß√£o de estados</td><td>M√≥dulo 6</td></tr>\n      <tr><td>AFD</td><td>AFD m√≠nimo</td><td>Algoritmo de Myhill-Nerode / Parti√ß√µes</td><td>M√≥dulo 5</td></tr>\n    </tbody></table>\n  </div>\n</section>\n\n<section id=\"quiz\">\n  <h2><span class=\"num\">9</span> Exerc√≠cios ‚Äî estilo POSCOMP</h2>\n\n  <div class=\"quiz\">\n    <h3>Quest√£o 1</h3>\n    <p>Um AFN tem estados Q = {q0, q1, q2} e as seguintes Œµ-transi√ß√µes: Œ¥(q0,Œµ) = {q1}, Œ¥(q1,Œµ) = {q2}, Œ¥(q2,Œµ) = ‚àÖ. Qual √© Œµ-closure(q0)?</p>\n    <div class=\"options\" id=\"q1\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"A\"> A) {q0}</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"B\"> B) {q0, q1}</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"C\"> C) {q0, q1, q2}</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q1\" value=\"D\"> D) {q1, q2}</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q1\" data-answer-key=\"C\" data-explanation-id=\"Œµ-closure sempre inclui o pr√≥prio estado. De q0, Œµ leva a q1. De q1, Œµ leva a q2. De q2, nenhuma Œµ-transi√ß√£o. Resultado: {q0, q1, q2}.\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q1-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Quest√£o 2</h3>\n    <p>Um AFN N tem 4 estados. Na constru√ß√£o de subconjuntos, qual √© o n√∫mero m√°ximo de estados que o AFD equivalente pode ter?</p>\n    <div class=\"options\" id=\"q2\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"A\"> A) 4</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"B\"> B) 8</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"C\"> C) 16</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q2\" value=\"D\"> D) 256</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q2\" data-answer-key=\"C\" data-explanation-id=\"O AFD tem estados correspondentes a subconjuntos de Q. Como |Q|=4, o conjunto das partes 2^Q tem 2‚Å¥=16 elementos. No pior caso, todos os 16 subconjuntos s√£o alcan√ß√°veis e se tornam estados do AFD.\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q2-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Quest√£o 3</h3>\n    <p>Considere um AFN N com Œ¥(q0,'a') = {q1, q2}, Œ¥(q1,'b') = {q3}, Œ¥(q2,'b') = ‚àÖ, F = {q3}. Qual √© o resultado da execu√ß√£o de \"ab\"?</p>\n    <div class=\"options\" id=\"q3\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"A\"> A) Rejeita, pois Œ¥(q2,'b') = ‚àÖ</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"B\"> B) Aceita, pois pelo menos um caminho (via q1) chega a q3 ‚àà F</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"C\"> C) Indefinido, pois Œ¥(q2,'b') = ‚àÖ</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q3\" value=\"D\"> D) Rejeita, pois o AFN √© n√£o-determin√≠stico</label>\n    </div>\n    <button class=\"quiz-btn\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q3-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Quest√£o 4 ‚Äî POSCOMP n√≠vel dif√≠cil</h3>\n    <p>Qual das afirma√ß√µes sobre AFN e AFD √© FALSA?</p>\n    <div class=\"options\" id=\"q4\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"A\"> A) Todo AFD √© um caso especial de AFN</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"B\"> B) Para qualquer AFN com n estados, existe um AFD equivalente com no m√°ximo 2‚Åø estados</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"C\"> C) AFN podem reconhecer linguagens que AFD n√£o conseguem</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q4\" value=\"D\"> D) A linguagem reconhecida por um AFN √© sempre regular</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q4\" data-answer-key=\"C\" data-explanation-id=\"C √© FALSA ‚Äî pelo Teorema de Rabin &amp; Scott, AFN e AFD reconhecem exatamente as mesmas linguagens (as regulares). A √© verdadeira: AFD √© AFN com |Œ¥(q,a)|=1 sempre. B √© verdadeira: constru√ß√£o de subconjuntos gera no m√°ximo 2‚Åø estados. D √© verdadeira por defini√ß√£o.\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q4-res\"></div>\n  </div>\n\n  <div class=\"quiz\">\n    <h3>Quest√£o 5 ‚Äî Constru√ß√£o de subconjuntos</h3>\n    <p>Na constru√ß√£o de subconjuntos de um AFN N = ({q0,q1,q2}, {0,1}, Œ¥, q0, {q2}) com Œ¥(q0,0)={q0,q1}, Œ¥(q0,1)={q0}, Œ¥(q1,1)={q2}, Œ¥(q1,0)=‚àÖ, Œ¥(q2,0)=Œ¥(q2,1)=‚àÖ: qual subconjunto do AFD √© estado de aceita√ß√£o?</p>\n    <div class=\"options\" id=\"q5\">\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"A\"> A) Apenas {q2}</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"B\"> B) Qualquer subconjunto que contenha q2</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"C\"> C) Qualquer subconjunto n√£o-vazio</label>\n      <label class=\"opt\"><input type=\"radio\" name=\"q5\" value=\"D\"> D) Apenas {q0, q1, q2}</label>\n    </div>\n    <button class=\"quiz-btn\" data-question-id=\"q5\" data-answer-key=\"B\" data-explanation-id=\"No AFD constru√≠do, um estado (subconjunto S) √© de aceita√ß√£o se e somente se S ‚à© F ‚â† ‚àÖ, onde F = {q2}. Portanto, qualquer subconjunto que contenha q2 ‚Äî como {q2}, {q0,q2}, {q1,q2}, {q0,q1,q2} ‚Äî √© estado de aceita√ß√£o do AFD.\">Verificar</button>\n    <div class=\"quiz-result\" id=\"q5-res\"></div>\n  </div>\n</section>\n\n<section id=\"resumo\">\n  <h2><span class=\"num\">10</span> Resumo do m√≥dulo</h2>\n\n  <div class=\"summary\">\n    <h3>O que voc√™ agora domina:</h3>\n    <div class=\"row\">AFN: Œ¥ retorna um conjunto de estados 2^Q, n√£o um √∫nico estado.</div>\n    <div class=\"row\">Œµ-transi√ß√µes permitem mudar de estado sem consumir s√≠mbolo da entrada.</div>\n    <div class=\"row\">Œµ-closure(q) = conjunto de todos os estados alcan√ß√°veis por zero ou mais Œµ-transi√ß√µes a partir de q.</div>\n    <div class=\"row\">Execu√ß√£o do AFN: mant√©m um conjunto de estados ativos; aplica Move + Œµ-closure a cada passo.</div>\n    <div class=\"row\">Aceita se, ao final, o conjunto ativo ‚à© F ‚â† ‚àÖ.</div>\n    <div class=\"row\">Constru√ß√£o de subconjuntos converte AFN ‚Üí AFD equivalente (no m√°ximo 2^n estados).</div>\n    <div class=\"row\">Teorema de Rabin &amp; Scott: AFN e AFD reconhecem exatamente as mesmas linguagens regulares.</div>\n    <div class=\"row\">AFN √© preferido no design; AFD, na implementa√ß√£o.</div>\n  </div>\n\n  <h3>O que vem no pr√≥ximo m√≥dulo</h3>\n  <div class=\"card\">\n    O M√≥dulo 4 cobre <strong>opera√ß√µes sobre linguagens regulares e propriedades de fechamento</strong>: como construir aut√¥matos para a uni√£o, concatena√ß√£o, interse√ß√£o e complemento de linguagens. Voc√™ ver√° por que as linguagens regulares formam uma √°lgebra fechada ‚Äî e como isso facilita a constru√ß√£o de AFDs complexos.\n  </div>\n</section>"
}
